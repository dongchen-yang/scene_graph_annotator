<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScanNet Scene Graph Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
        }

        #left-panel {
            width: 220px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #objects-panel {
            width: 350px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #relationships-panel {
            width: 300px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #left-panel h2, #objects-panel h2, #relationships-panel h2 {
            padding: 15px;
            background: #2c3e50;
            color: white;
            font-size: 16px;
            margin: 0;
        }

        #file-loader {
            padding: 15px;
            border-bottom: 1px solid #ddd;
            background: white;
        }

        #file-loader h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
        }

        .file-input-group {
            margin-bottom: 15px;
        }

        .file-input-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .file-input-group input[type="file"] {
            width: 100%;
            padding: 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .file-status {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .file-status.loaded {
            color: #27ae60;
        }

        #scene-info {
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            background: #e8f4f8;
        }

        #scene-info h3 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: bold;
        }

        #scene-info p {
            font-size: 11px;
            color: #555;
            margin: 3px 0;
            line-height: 1.4;
        }

        #object-filters, #relationship-filters {
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            background: #fff9e6;
        }

        #object-filters h3, #relationship-filters h3 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: bold;
        }

        .filter-section {
            margin-bottom: 8px;
        }

        .filter-section label {
            font-size: 11px;
            color: #555;
            display: block;
            margin-bottom: 4px;
        }

        .filter-section select {
            width: 100%;
            padding: 5px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .filter-chip {
            display: inline-flex;
            align-items: center;
            padding: 3px 8px;
            background: #3498db;
            color: white;
            font-size: 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .filter-chip:hover {
            background: #2980b9;
        }

        .filter-chip .remove {
            margin-left: 5px;
            font-weight: bold;
            font-size: 12px;
        }

        .clear-filters-btn {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 5px;
            width: 100%;
        }

        .clear-filters-btn:hover {
            background: #7f8c8d;
        }

        #objects-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        #objects-list h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
        }

        .object-item {
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .object-item:hover {
            border-color: #3498db;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .object-item.selected {
            border-color: #3498db;
            background: #ebf5fb;
        }

        .object-item .object-id {
            font-weight: bold;
            color: #2c3e50;
            font-size: 13px;
        }

        .object-item .object-labels {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 4px;
        }

        .object-item .object-attributes {
            font-size: 11px;
            color: #16a085;
            margin-top: 4px;
            font-style: italic;
        }

        .attribute-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            margin: 2px 2px 0 0;
            background: #e8f8f5;
            border: 1px solid #16a085;
            border-radius: 3px;
            font-size: 10px;
            font-style: normal;
        }
        
        .attribute-tag.validated-correct {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .attribute-tag.validated-incorrect {
            background: #f8d7da;
            border-color: #dc3545;
            text-decoration: line-through;
        }
        
        .attr-validation-btns {
            display: inline-flex;
            gap: 2px;
            margin-left: 4px;
        }
        
        .attr-validation-btn {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            line-height: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .attr-validation-btn.correct {
            background: #28a745;
            color: white;
        }
        
        .attr-validation-btn.correct:hover {
            background: #218838;
        }
        
        .attr-validation-btn.incorrect {
            background: #dc3545;
            color: white;
        }
        
        .attr-validation-btn.incorrect:hover {
            background: #c82333;
        }
        
        .attr-validation-btn.active {
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        
        #validation-stats {
            padding: 10px 15px;
            background: #fff3cd;
            border-bottom: 1px solid #ddd;
            font-size: 12px;
        }
        
        #validation-stats .stat {
            display: inline-block;
            margin-right: 15px;
        }
        
        #export-validations-btn {
            padding: 5px 10px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-top: 5px;
        }
        
        #export-validations-btn:hover {
            background: #138496;
        }
        
        /* Relationship validation styles */
        .relationship-item {
            padding: 8px;
            margin-bottom: 6px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .relationship-item.validated-correct {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .relationship-item.validated-incorrect {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        .relationship-item.added-relationship {
            background: #d4edda;
            border-color: #28a745;
            border-style: dashed;
        }
        
        .rel-validation-btns {
            display: inline-flex;
            gap: 4px;
            margin-left: 8px;
        }
        
        .rel-validation-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .rel-validation-btn.correct {
            background: #28a745;
            color: white;
        }
        
        .rel-validation-btn.incorrect {
            background: #dc3545;
            color: white;
        }
        
        .rel-validation-btn:hover {
            opacity: 0.8;
        }
        
        .rel-validation-btn.active {
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        
        .rel-delete-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            background: #6c757d;
            color: white;
            margin-left: 4px;
        }
        
        .rel-delete-btn:hover {
            background: #5a6268;
        }
        
        .highlight-both-btn {
            width: 22px;
            height: 22px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            background: #f0f0f0;
            color: #666;
            margin-left: 4px;
            padding: 0;
        }
        
        .highlight-both-btn:hover {
            background: #e0e0e0;
            border-color: #999;
        }
        
        .highlight-both-btn.active {
            background: #ffc107;
            border-color: #ffc107;
            color: #000;
        }
        
        #add-relationship-section {
            padding: 10px;
            background: #f8f9fa;
            border-top: 1px solid #ddd;
            margin-top: 10px;
        }
        
        #add-relationship-section h4 {
            font-size: 12px;
            margin: 0 0 8px 0;
            color: #333;
        }
        
        .add-rel-row {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
            align-items: center;
        }
        
        .add-rel-select, .add-rel-input {
            padding: 4px 6px;
            font-size: 11px;
            border: 1px solid #ced4da;
            border-radius: 3px;
        }
        
        .add-rel-select {
            flex: 1;
        }
        
        .add-rel-input {
            width: 100px;
        }
        
        .add-rel-btn {
            padding: 4px 10px;
            font-size: 11px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .add-rel-btn:hover {
            background: #218838;
        }
        
        #rel-validation-stats {
            padding: 8px 10px;
            background: #e7f3ff;
            font-size: 11px;
            border-bottom: 1px solid #ddd;
        }
        
        #rel-validation-stats .stat {
            display: inline-block;
            margin-right: 10px;
        }
        
        /* Additional attribute annotation styles */
        .add-attribute-section {
            margin-top: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px dashed #dee2e6;
        }
        
        .add-attribute-section.hidden {
            display: none;
        }
        
        .add-attr-row {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
        }
        
        .add-attr-input {
            flex: 1;
            padding: 4px 6px;
            font-size: 11px;
            border: 1px solid #ced4da;
            border-radius: 3px;
        }
        
        .add-attr-btn {
            padding: 4px 8px;
            font-size: 11px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            background: #28a745;
            color: white;
        }
        
        .add-attr-btn:hover {
            background: #218838;
        }
        
        .attribute-tag.annotated-added {
            background: #d4edda;
            border-color: #28a745;
            border-style: dashed;
        }
        
        .attr-delete-btn {
            width: 14px;
            height: 14px;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-size: 10px;
            line-height: 14px;
            padding: 0;
            background: #6c757d;
            color: white;
            margin-left: 2px;
        }
        
        .attr-delete-btn:hover {
            background: #5a6268;
        }
        
        .toggle-add-attr-btn {
            font-size: 10px;
            padding: 2px 6px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 4px;
        }
        
        .toggle-add-attr-btn:hover {
            background: #5a6268;
        }

        #relationships-content {
            padding: 15px;
            flex: 1;
            overflow-y: auto;
        }

        #relationships-content h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #333;
        }

        #annotations-section {
            padding: 15px;
            border-top: 1px solid #ddd;
            background: #f0f8ff;
        }

        #annotations-section h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #333;
        }

        .annotation-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-left: 3px solid #9c27b0;
            font-size: 11px;
            color: #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .annotation-item .delete-btn {
            background: #e57373;
            color: white;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .annotation-item .delete-btn:hover {
            background: #ef5350;
        }

        .annotation-pending {
            background: #fff3cd;
            padding: 8px;
            border-left: 3px solid #ffc107;
            font-size: 11px;
            margin-bottom: 10px;
        }

        .relationship-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-left: 3px solid #3498db;
            font-size: 12px;
            color: #555;
        }
        
        .relationship-item.in-between-item {
            background: #e8f4fc;
            border-left: 3px solid #17a2b8;
        }

        .relationship-item .rel-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .relationship-item .rel-target {
            color: #3498db;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .relationship-item .rel-target:hover {
            text-decoration: underline;
            background: #ebf5fb;
        }

        .relationship-item .rel-target.highlighted {
            background: #ffa726;
            color: white;
            font-weight: bold;
            border: 2px solid #ff6f00;
            padding: 2px 6px;
            box-shadow: 0 2px 4px rgba(255, 111, 0, 0.3);
        }

        .candidate-item {
            padding: 10px;
            margin-bottom: 5px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .candidate-item:hover {
            border-color: #9c27b0;
            background: #f3e5f5;
            box-shadow: 0 2px 4px rgba(156, 39, 176, 0.2);
        }

        .candidate-item.previewing {
            border-color: #42a5f5;
            border-width: 2px;
            background: #e3f2fd;
            box-shadow: 0 3px 6px rgba(66, 165, 245, 0.4);
        }

        .candidate-info {
            flex: 1;
            cursor: pointer;
        }

        .candidate-item.same-class {
            border-left: 4px solid #4caf50;
        }

        .candidate-item.different-class {
            border-left: 4px solid #ff9800;
        }

        .candidate-item .candidate-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 12px;
        }

        .candidate-item .candidate-class {
            font-size: 10px;
            color: #7f8c8d;
            margin-top: 3px;
        }

        .candidate-item .candidate-match {
            font-size: 9px;
            margin-top: 3px;
        }

        .candidate-item.same-class .candidate-match {
            color: #4caf50;
        }

        .candidate-item.different-class .candidate-match {
            color: #ff9800;
        }

        .annotate-btn {
            background: #9c27b0;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .annotate-btn:hover {
            background: #7b1fa2;
            box-shadow: 0 2px 4px rgba(156, 39, 176, 0.4);
        }

        .annotate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .preview-btn {
            background: #42a5f5;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 5px;
        }

        .preview-btn:hover {
            background: #1976d2;
        }

        #viewer {
            flex: 1;
            position: relative;
            background: #1a1a1a;
        }

        #viewer canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        #controls label {
            display: block;
            margin-bottom: 5px;
        }

        #controls input[type="checkbox"] {
            margin-right: 5px;
        }
        
        .mode-btn {
            padding: 4px 8px;
            font-size: 10px;
            border: 1px solid #555;
            border-radius: 3px;
            background: #444;
            color: #ccc;
            cursor: pointer;
        }
        
        .mode-btn:hover {
            background: #555;
        }
        
        .mode-btn.active {
            background: #3498db;
            border-color: #3498db;
            color: white;
        }
        
        .mode-btn.active.similarity {
            background: #9c27b0;
            border-color: #9c27b0;
        }
        
        .mode-btn.active.attribute {
            background: #28a745;
            border-color: #28a745;
        }
        
        .mode-btn.active.relationship {
            background: #17a2b8;
            border-color: #17a2b8;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }

        .hidden {
            display: none;
        }

        .info-box {
            padding: 15px;
            margin: 15px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            font-size: 12px;
            color: #856404;
        }

        #scene-selector-section {
            padding: 15px;
            border-bottom: 1px solid #ddd;
            background: white;
        }

        #scene-selector-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
        }

        #scenes-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .scene-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .scene-item:hover {
            border-color: #3498db;
            background: #ebf5fb;
        }

        .scene-item.selected {
            border-color: #3498db;
            background: #3498db;
            color: white;
        }
    </style>
</head>
<body>
    <div id="left-panel">
        <h2>Scenes</h2>
        
        <div class="info-box">
            <strong>Controls:</strong><br>
            ‚Ä¢ Left-click: Rotate<br>
            ‚Ä¢ Right-click: Pan<br>
            ‚Ä¢ Wheel: Zoom<br>
        </div>

        <div id="scene-selector-section">
            <h3>Available Scenes</h3>
            <div id="scenes-list">
                <!-- Scenes will be populated here -->
            </div>
        </div>
        
        <div id="file-loader" style="display: none;">
            <h3>Load Files</h3>
            <div class="file-input-group">
                <label for="scene-graph-file">Scene Graph JSON:</label>
                <input type="file" id="scene-graph-file" accept=".json">
                <div id="sg-status" class="file-status"></div>
            </div>
            <div class="file-input-group">
                <label for="ply-file">Point Cloud PLY:</label>
                <input type="file" id="ply-file" accept=".ply">
                <div id="ply-status" class="file-status"></div>
            </div>
        </div>
    </div>

    <div id="viewer">
        <div id="loading" class="loading hidden">Loading...</div>
        <div id="controls">
            <label><input type="checkbox" id="show-all-bboxes"> Show All Bounding Boxes</label>
            <label><input type="checkbox" id="show-points" checked> Show Mesh</label>
            <label id="point-size-control" style="display: none;">Point Size: <input type="range" id="point-size" min="0.1" max="30" step="0.1" value="8.0">
                <span id="point-size-value">8.0</span></label>
            <hr style="margin: 10px 0; border-color: #555;">
            <div style="font-size: 12px; margin-bottom: 5px;">Annotation Mode:</div>
            <div id="annotation-mode-buttons" style="display: flex; gap: 4px; flex-wrap: wrap;">
                <button class="mode-btn" id="mode-none" onclick="setAnnotationMode(null)">Off</button>
                <button class="mode-btn" id="mode-similarity" onclick="setAnnotationMode('similarity')">Similarity</button>
                <button class="mode-btn" id="mode-attribute" onclick="setAnnotationMode('attribute')">Attribute</button>
                <button class="mode-btn" id="mode-relationship" onclick="setAnnotationMode('relationship')">Relationship</button>
            </div>
            <div id="annotation-info" style="font-size: 11px; color: #ccc; margin-top: 5px; display: none;"></div>
            <button id="export-annotations" style="margin-top: 5px; padding: 5px 10px;">Export All Annotations</button>
        </div>
    </div>

    <div id="objects-panel">
        <h2>Objects</h2>
        
        <div id="scene-info">
            <h3>Current Scene</h3>
            <p id="scene-summary">Select a scene to view information</p>
        </div>

        <div id="object-filters">
            <h3>üîç Filter Objects</h3>
            <div class="filter-section">
                <label for="attribute-filter">By Attribute:</label>
                <select id="attribute-filter">
                    <option value="">All attributes</option>
                </select>
                <div id="selected-attributes" class="filter-chips"></div>
            </div>
            <button id="clear-object-filters" class="clear-filters-btn" style="display: none;">Clear Filters</button>
        </div>

        <div id="validation-stats">
            <span class="stat"><strong>Total:</strong> 0</span>
            <span class="stat" style="color: #28a745;"><strong>Correct:</strong> 0</span>
            <span class="stat" style="color: #dc3545;"><strong>Incorrect:</strong> 0</span>
            <span class="stat"><strong>Remaining:</strong> 0</span>
            <button id="export-validations-btn" onclick="exportAttributeValidations()">Export Validations</button>
        </div>

        <div id="objects-list">
            <div id="objects-container"></div>
        </div>
    </div>

        <div id="relationships-panel">
        <h2 id="relationships-title">Relationships</h2>
        
        <div id="relationship-filters">
            <h3>üîç Filter Relationships</h3>
            <div class="filter-section">
                <label for="relationship-type-filter">By Type:</label>
                <select id="relationship-type-filter">
                    <option value="">All types</option>
                </select>
                <div id="selected-rel-types" class="filter-chips"></div>
            </div>
            <button id="clear-rel-filters" class="clear-filters-btn" style="display: none;">Clear Filters</button>
        </div>
        
        <div id="relationships-content">
            <div id="relationships-container">Select an object to view its relationships</div>
        </div>

        <div id="annotations-section">
            <h3>Similarity Annotations</h3>
            <div id="annotations-container">No annotations yet</div>
        </div>
    </div>

    <script>
        // PLY file parser - handles both ASCII and binary
        async function parsePLY(data) {
            let text, arrayBuffer;
            if (data instanceof ArrayBuffer) {
                arrayBuffer = data;
                // Read entire header as text (up to first \n\n after end_header)
                const headerBytes = new Uint8Array(arrayBuffer, 0, Math.min(2000, arrayBuffer.byteLength));
                let headerText = '';
                let endHeaderFound = false;
                for (let i = 0; i < headerBytes.length; i++) {
                    const byte = headerBytes[i];
                    headerText += String.fromCharCode(byte);
                    if (byte === 10) { // newline
                        if (headerText.includes('end_header')) {
                            endHeaderFound = true;
                        }
                        if (endHeaderFound && headerBytes[i+1] === 10) {
                            // Found double newline after end_header, this is the end
                            break;
                        }
                    }
                }
                text = headerText;
            } else {
                text = data;
                arrayBuffer = null;
            }
            
            const lines = text.split('\n');
            let vertexCount = 0;
            let faceCount = 0;
            let headerEnd = 0;
            let hasColors = false;
            let hasNormals = false;
            let isBinary = false;
            let headerLength = 0;
            
            // Parse header
            let inVertexElement = false;
            let inFaceElement = false;
            let bytesPerVertex = 0;  // Total bytes per vertex (computed from header)
            let colorOffset = -1;  // Offset within vertex where colors start (-1 if no colors)
            let xOffset = 0, yOffset = 4, zOffset = 8;  // Default positions for x, y, z
            let xyzIsDouble = false;  // Whether x, y, z are doubles (8 bytes) or floats (4 bytes)
            let faceExtraBytes = 0;  // Extra bytes per face beyond vertex indices
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.includes('format binary')) {
                    isBinary = true;
                }
                if (line.startsWith('element vertex')) {
                    vertexCount = parseInt(line.split(' ')[2]);
                    inVertexElement = true;
                    inFaceElement = false;
                    bytesPerVertex = 0;
                }
                if (line.startsWith('element face')) {
                    faceCount = parseInt(line.split(' ')[2]);
                    inVertexElement = false;
                    inFaceElement = true;
                    faceExtraBytes = 0;
                }
                if (line.startsWith('element') && !line.startsWith('element vertex') && !line.startsWith('element face')) {
                    // Some other element (e.g., edge)
                    inVertexElement = false;
                    inFaceElement = false;
                }
                if (inVertexElement && line.startsWith('property')) {
                    // Count bytes for ALL vertex properties and track positions
                    if (line.includes('property uchar red')) {
                        colorOffset = bytesPerVertex;  // Mark where colors start
                        hasColors = true;
                    }
                    // Track x, y, z property positions and data type
                    if (line.includes('property double x')) {
                        xOffset = bytesPerVertex;
                        xyzIsDouble = true;
                    } else if (line.includes('property float x')) {
                        xOffset = bytesPerVertex;
                    }
                    if (line.includes('property double y') || line.includes('property float y')) {
                        yOffset = bytesPerVertex;
                    }
                    if (line.includes('property double z') || line.includes('property float z')) {
                        zOffset = bytesPerVertex;
                    }
                    if (line.includes('uchar') || line.includes('char')) bytesPerVertex += 1;
                    else if (line.includes('ushort') || line.includes('short')) bytesPerVertex += 2;
                    else if (line.includes('uint') || line.includes('int') || line.includes('float')) bytesPerVertex += 4;
                    else if (line.includes('double')) bytesPerVertex += 8;
                }
                if (inFaceElement && line.startsWith('property')) {
                    // Count bytes for face properties beyond vertex_indices
                    if (!line.includes('vertex_indices')) {
                        if (line.includes('uchar')) faceExtraBytes += 1;
                        else if (line.includes('ushort') || line.includes('short')) faceExtraBytes += 2;
                        else if (line.includes('uint') || line.includes('int') || line.includes('float')) faceExtraBytes += 4;
                        else if (line.includes('double')) faceExtraBytes += 8;
                    }
                }
                if (line.includes('property float nx') || line.includes('property float ny') || line.includes('property float nz')) {
                    hasNormals = true;
                }
                if (line.includes('property uchar red') || line.includes('property uchar green') || line.includes('property uchar blue')) {
                    hasColors = true;
                }
                if (line === 'end_header') {
                    headerEnd = i + 1;
                    // Calculate header length in bytes - find the byte position after end_header\n
                    if (arrayBuffer) {
                        // Search for "end_header" followed by newline in the raw bytes
                        const headerBytes = new Uint8Array(arrayBuffer, 0, Math.min(2000, arrayBuffer.byteLength));
                        let foundEnd = false;
                        for (let j = 0; j < headerBytes.length - 10; j++) {
                            let match = true;
                            const endHeaderStr = 'end_header';
                            for (let k = 0; k < endHeaderStr.length; k++) {
                                if (headerBytes[j + k] !== endHeaderStr.charCodeAt(k)) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match && headerBytes[j + endHeaderStr.length] === 10) {
                                // Found "end_header\n", header ends at j + endHeaderStr.length + 1
                                headerLength = j + endHeaderStr.length + 1;
                                foundEnd = true;
                                break;
                            }
                        }
                        if (!foundEnd) {
                            // Fallback: calculate from text
                            const headerTextUpToEnd = lines.slice(0, i + 1).join('\n') + '\n';
                            headerLength = new TextEncoder().encode(headerTextUpToEnd).length;
                        }
                    }
                    break;
                }
            }
            
            if (isBinary && arrayBuffer) {
                // If bytesPerVertex wasn't computed (e.g., empty or bad header), fall back to estimate
                if (bytesPerVertex === 0) {
                    bytesPerVertex = 12; // x, y, z minimum
                    if (hasNormals) bytesPerVertex += 12;
                    if (hasColors) bytesPerVertex += 4;
                    colorOffset = hasNormals ? 24 : 12;
                    xOffset = 0; yOffset = 4; zOffset = 8;
                }
                console.log('PLY Header parsed: bytesPerVertex=' + bytesPerVertex + ', x/y/z offsets=' + xOffset + '/' + yOffset + '/' + zOffset + ', xyzIsDouble=' + xyzIsDouble + ', colorOffset=' + colorOffset);
                return parseBinaryPLY(arrayBuffer, headerLength, vertexCount, faceCount, hasColors, bytesPerVertex, colorOffset, xOffset, yOffset, zOffset, xyzIsDouble, faceExtraBytes);
            } else {
                // For ASCII PLY, we need the full text content, not just the header
                let fullText = text;
                if (arrayBuffer) {
                    // Decode the entire ArrayBuffer as text for ASCII PLY
                    const decoder = new TextDecoder('utf-8');
                    fullText = decoder.decode(arrayBuffer);
                }
                return parseASCIIPLY(fullText, headerEnd, vertexCount, faceCount, hasColors, hasNormals);
            }
        }
        
        // Convert sRGB color value to linear space for proper rendering
        function sRGBToLinear(c) {
            return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        }
        
        function parseASCIIPLY(text, headerEnd, vertexCount, faceCount, hasColors) {
            const lines = text.split('\n');
            const points = [];
            const colors = [];
            const indices = [];
            
            // Parse vertices
            const dataLines = lines.slice(headerEnd, headerEnd + vertexCount);
            dataLines.forEach(line => {
                if (!line.trim()) return;
                const parts = line.trim().split(/\s+/);
                if (parts.length >= 3) {
                    let x = parseFloat(parts[0]);
                    let y = parseFloat(parts[1]);
                    let z = parseFloat(parts[2]);
                    // Replace NaN or invalid values with 0
                    if (isNaN(x) || !isFinite(x)) x = 0;
                    if (isNaN(y) || !isFinite(y)) y = 0;
                    if (isNaN(z) || !isFinite(z)) z = 0;
                    points.push(x, y, z);
                    
                    if (hasColors && parts.length >= 6) {
                        // Convert from sRGB to linear space for correct rendering
                        const r = parseInt(parts[3]) / 255;
                        const g = parseInt(parts[4]) / 255;
                        const b = parseInt(parts[5]) / 255;
                        colors.push(
                            sRGBToLinear(r),
                            sRGBToLinear(g),
                            sRGBToLinear(b)
                        );
                    }
                }
            });
            
            // Parse faces
            if (faceCount > 0) {
                const faceStart = headerEnd + vertexCount;
                const faceLines = lines.slice(faceStart, faceStart + faceCount);
                const maxVertex = (points.length / 3) - 1;
                faceLines.forEach(line => {
                    if (!line.trim()) return;
                    const parts = line.trim().split(/\s+/);
                    const numVerts = parseInt(parts[0]);
                    if (numVerts === 3 && parts.length >= 4) {
                        // Triangle - validate indices
                        const v0 = parseInt(parts[1]);
                        const v1 = parseInt(parts[2]);
                        const v2 = parseInt(parts[3]);
                        if (v0 >= 0 && v0 <= maxVertex && v1 >= 0 && v1 <= maxVertex && v2 >= 0 && v2 <= maxVertex) {
                            indices.push(v0, v1, v2);
                        }
                    }
                });
            }
            
            return { points, colors, indices, hasColors: hasColors && colors.length > 0, hasFaces: faceCount > 0 };
        }
        
        function parseBinaryPLY(arrayBuffer, headerLength, vertexCount, faceCount, hasColors, bytesPerVertex, colorOffset, xOffset, yOffset, zOffset, xyzIsDouble, faceExtraBytes = 0) {
            console.log('Parsing binary PLY: headerLength=', headerLength, 'vertexCount=', vertexCount, 'faceCount=', faceCount, 'hasColors=', hasColors, 'bytesPerVertex=', bytesPerVertex, 'colorOffset=', colorOffset, 'xyzOffsets=', xOffset, yOffset, zOffset, 'xyzIsDouble=', xyzIsDouble, 'faceExtraBytes=', faceExtraBytes);
            const view = new DataView(arrayBuffer, headerLength);
            const points = [];
            const colors = [];
            const indices = [];
            let offset = 0;
            
            console.log('Total binary data size:', view.byteLength, 'Expected vertex data size:', vertexCount * bytesPerVertex);
            
            try {
                // Parse all vertices
                for (let i = 0; i < vertexCount; i++) {
                    if (offset + bytesPerVertex > view.byteLength) {
                        console.warn('Reached end of buffer at vertex', i);
                        break;
                    }
                    
                    // Read x, y, z from their actual positions (as double or float)
                    let x, y, z;
                    if (xyzIsDouble) {
                        x = view.getFloat64(offset + xOffset, true);
                        y = view.getFloat64(offset + yOffset, true);
                        z = view.getFloat64(offset + zOffset, true);
                    } else {
                        x = view.getFloat32(offset + xOffset, true);
                        y = view.getFloat32(offset + yOffset, true);
                        z = view.getFloat32(offset + zOffset, true);
                    }
                    
                    // Replace NaN with 0 (will be excluded from bounding box calculation)
                    if (isNaN(x) || !isFinite(x)) x = 0;
                    if (isNaN(y) || !isFinite(y)) y = 0;
                    if (isNaN(z) || !isFinite(z)) z = 0;
                    
                    points.push(x, y, z);
                    
                    if (hasColors && colorOffset >= 0 && offset + colorOffset + 4 <= view.byteLength) {
                        const r = view.getUint8(offset + colorOffset) / 255;
                        const g = view.getUint8(offset + colorOffset + 1) / 255;
                        const b = view.getUint8(offset + colorOffset + 2) / 255;
                        // Skip alpha at colorOffset + 3
                        // Convert from sRGB to linear space for correct rendering
                        colors.push(sRGBToLinear(r), sRGBToLinear(g), sRGBToLinear(b));
                    }
                    
                    offset += bytesPerVertex;
                }
                
                const actualVertexCount = points.length / 3;
                console.log('Parsed', actualVertexCount, 'vertices from binary PLY');
                console.log('Offset after vertices:', offset, '/', view.byteLength, 'bytes');
                console.log('Remaining bytes for faces:', view.byteLength - offset);
                console.log('Expected to parse', faceCount, 'faces');
                
                // Debug: show first few vertices to help diagnose data issues
                console.log('First 5 vertices:');
                for (let i = 0; i < Math.min(5, actualVertexCount); i++) {
                    console.log('  v' + i + ':', points[i*3].toFixed(4), points[i*3+1].toFixed(4), points[i*3+2].toFixed(4));
                }
                // Show some stats about coordinate ranges
                let validCount = 0, invalidCount = 0;
                let sampleInvalid = [];
                for (let i = 0; i < points.length; i += 3) {
                    const x = points[i], y = points[i+1], z = points[i+2];
                    if (Math.abs(x) < 100 && Math.abs(y) < 100 && Math.abs(z) < 100 && !(x === 0 && y === 0 && z === 0)) {
                        validCount++;
                    } else {
                        invalidCount++;
                        if (sampleInvalid.length < 3) sampleInvalid.push({i: i/3, x, y, z});
                    }
                }
                console.log('Coordinate check: valid=' + validCount + ', invalid=' + invalidCount);
                if (sampleInvalid.length > 0) console.log('Sample invalid vertices:', sampleInvalid);
                
                // Parse faces
                if (faceCount > 0) {
                    let invalidFaceCount = 0;
                    let facesProcessed = 0;
                    for (let i = 0; i < faceCount; i++) {
                        facesProcessed++;
                        if (offset + 1 > view.byteLength) {
                            console.warn('Ran out of buffer at face', i, 'offset:', offset, 'byteLength:', view.byteLength);
                            break;
                        }
                        
                        // Read number of vertices in face (uchar)
                        const numVerts = view.getUint8(offset);
                        offset += 1;
                        
                        if (numVerts === 3 && offset + 12 + faceExtraBytes <= view.byteLength) {
                            // Triangle - read 3 vertex indices as int32 (little endian)
                            const v0 = view.getInt32(offset, true);
                            const v1 = view.getInt32(offset + 4, true);
                            const v2 = view.getInt32(offset + 8, true);
                            const maxVertex = actualVertexCount - 1;
                            // Only add valid indices within vertex range
                            if (v0 >= 0 && v0 <= maxVertex && v1 >= 0 && v1 <= maxVertex && v2 >= 0 && v2 <= maxVertex) {
                                // Check if any vertex is at origin (likely a replaced NaN)
                                const v0IsOrigin = points[v0*3] === 0 && points[v0*3+1] === 0 && points[v0*3+2] === 0;
                                const v1IsOrigin = points[v1*3] === 0 && points[v1*3+1] === 0 && points[v1*3+2] === 0;
                                const v2IsOrigin = points[v2*3] === 0 && points[v2*3+1] === 0 && points[v2*3+2] === 0;
                                
                                // Skip triangles with vertices at origin
                                if (!v0IsOrigin && !v1IsOrigin && !v2IsOrigin) {
                                    indices.push(v0, v1, v2);
                                } else {
                                    invalidFaceCount++;
                                }
                            } else {
                                invalidFaceCount++;
                            }
                            offset += 12 + faceExtraBytes;  // Skip vertex indices and extra properties
                        } else {
                            // Skip other face types (quads, etc.) or invalid data
                            if (numVerts > 0 && numVerts < 10) {
                                offset += numVerts * 4 + faceExtraBytes;  // Skip vertex indices and extra properties
                            } else {
                                console.warn('Invalid face vertex count:', numVerts, 'at face', i, 'offset:', offset);
                                break;
                            }
                            if (offset > view.byteLength) {
                                console.warn('Offset exceeded after skipping non-triangle face');
                                break;
                            }
                        }
                    }
                    console.log('Parsed', indices.length / 3, 'valid faces from binary PLY');
                    console.log('Processed', facesProcessed, '/', faceCount, 'faces, skipped', invalidFaceCount, 'invalid');
                }
                
                return { points, colors, indices, hasColors: hasColors && colors.length > 0, hasFaces: faceCount > 0 };
            } catch (error) {
                console.error('Error parsing binary PLY:', error, 'at offset', offset);
                throw error;
            }
        }

        // Convert multiscan annotations format to scene graph format
        function convertMultiscanToSceneGraph(data) {
            const sceneId = data.scanId || 'unknown';
            const objects = [];
            
            // Convert multiscan objects to scene graph objects
            for (const obj of (data.objects || [])) {
                const objId = obj.objectId;
                const label = obj.label || 'unknown';
                const obb = obj.obb || {};
                
                // Extract OBB parameters
                const centroid = obb.centroid || [0, 0, 0];
                const axesLengths = obb.axesLengths || [1, 1, 1];
                const normalizedAxes = obb.normalizedAxes || [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
                
                // normalizedAxes can be either:
                // - 9 elements: 3x3 rotation matrix [m00,m01,m02, m10,m11,m12, m20,m21,m22] (row-major)
                // - 16 elements: 4x4 matrix [m00,m01,m02,m03, m10,m11,m12,m13, m20,m21,m22,m23, m30,m31,m32,m33]
                let m00, m01, m02, m10, m11, m12, m20, m21, m22;
                if (normalizedAxes.length === 9) {
                    // 3x3 matrix (row-major)
                    m00 = normalizedAxes[0]; m01 = normalizedAxes[1]; m02 = normalizedAxes[2];
                    m10 = normalizedAxes[3]; m11 = normalizedAxes[4]; m12 = normalizedAxes[5];
                    m20 = normalizedAxes[6]; m21 = normalizedAxes[7]; m22 = normalizedAxes[8];
                } else {
                    // 4x4 matrix - extract 3x3 rotation part
                    m00 = normalizedAxes[0]; m01 = normalizedAxes[1]; m02 = normalizedAxes[2];
                    m10 = normalizedAxes[4]; m11 = normalizedAxes[5]; m12 = normalizedAxes[6];
                    m20 = normalizedAxes[8]; m21 = normalizedAxes[9]; m22 = normalizedAxes[10];
                }
                
                // Convert rotation matrix to quaternion
                // First validate that matrix values are finite
                const matrixValid = [m00, m01, m02, m10, m11, m12, m20, m21, m22].every(v => isFinite(v));
                let qw = 1, qx = 0, qy = 0, qz = 0;  // Default to identity quaternion
                
                if (matrixValid) {
                    const trace = m00 + m11 + m22;
                    
                    if (trace > 0) {
                        const s = 0.5 / Math.sqrt(trace + 1.0);
                        qw = 0.25 / s;
                        qx = (m21 - m12) * s;
                        qy = (m02 - m20) * s;
                        qz = (m10 - m01) * s;
                    } else if (m00 > m11 && m00 > m22) {
                        const s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);
                        qw = (m21 - m12) / s;
                        qx = 0.25 * s;
                        qy = (m01 + m10) / s;
                        qz = (m02 + m20) / s;
                    } else if (m11 > m22) {
                        const s = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);
                        qw = (m02 - m20) / s;
                        qx = (m01 + m10) / s;
                        qy = 0.25 * s;
                        qz = (m12 + m21) / s;
                    } else {
                        const s = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);
                        qw = (m10 - m01) / s;
                        qx = (m02 + m20) / s;
                        qy = (m12 + m21) / s;
                        qz = 0.25 * s;
                    }
                    
                    // Validate quaternion result
                    if (!isFinite(qx) || !isFinite(qy) || !isFinite(qz) || !isFinite(qw)) {
                        qw = 1; qx = 0; qy = 0; qz = 0;  // Fallback to identity
                    }
                }
                
                const rotation = [qx, qy, qz, qw];  // [qx, qy, qz, qw]
                
                // Half dimensions (multiscan uses full lengths)
                const halfDims = axesLengths.map(d => d / 2);
                
                objects.push({
                    id: objId,
                    labels: [label],
                    bbox: {
                        center: centroid,
                        half_dims: halfDims,
                        rotation: rotation
                    },
                    mobilityType: obj.mobilityType || 'unknown',
                    partIds: obj.partIds || []
                });
            }
            
            // Build attributes from object properties
            const attributes = {};
            for (const obj of objects) {
                const objAttrs = [];
                if (obj.mobilityType && obj.mobilityType !== 'unknown') {
                    objAttrs.push(obj.mobilityType);  // 'fixed' or 'movable'
                }
                if (objAttrs.length > 0) {
                    attributes[obj.id] = objAttrs;
                }
            }
            
            // Build relationships from parts hierarchy
            const relationships = [];
            const parts = data.parts || [];
            
            // Create a map from partId to objectId
            const partToObject = {};
            for (const obj of objects) {
                for (const partId of (obj.partIds || [])) {
                    partToObject[partId] = obj.id;
                }
            }
            
            // Create part-of relationships based on parentId
            for (const part of parts) {
                if (part.parentId !== undefined) {
                    const childObjId = partToObject[part.partId];
                    const parentObjId = partToObject[part.parentId];
                    
                    if (childObjId !== undefined && parentObjId !== undefined && childObjId !== parentObjId) {
                        relationships.push({
                            subject: childObjId,
                            predicate: 'part of',
                            object: parentObjId
                        });
                    }
                }
                
                // Add articulation info as relationships
                if (part.articulations && part.articulations.length > 0) {
                    const objId = partToObject[part.partId];
                    if (objId !== undefined) {
                        for (const art of part.articulations) {
                            if (art.type === 'rotation') {
                                // Object can rotate (e.g., door, drawer)
                                if (!attributes[objId]) attributes[objId] = [];
                                if (!attributes[objId].includes('rotatable')) {
                                    attributes[objId].push('rotatable');
                                }
                            } else if (art.type === 'translation') {
                                // Object can slide (e.g., drawer)
                                if (!attributes[objId]) attributes[objId] = [];
                                if (!attributes[objId].includes('slidable')) {
                                    attributes[objId].push('slidable');
                                }
                            }
                        }
                    }
                }
            }
            
            // Infer spatial relationships based on bounding box positions
            for (let i = 0; i < objects.length; i++) {
                for (let j = i + 1; j < objects.length; j++) {
                    const obj1 = objects[i];
                    const obj2 = objects[j];
                    
                    const c1 = obj1.bbox.center;
                    const c2 = obj2.bbox.center;
                    const h1 = obj1.bbox.half_dims;
                    const h2 = obj2.bbox.half_dims;
                    
                    // Check vertical relationships (Y is up in this coordinate system)
                    const verticalDist = c1[1] - c2[1];
                    const horizontalDist = Math.sqrt(Math.pow(c1[0] - c2[0], 2) + Math.pow(c1[2] - c2[2], 2));
                    
                    // If objects are vertically close and one is above the other
                    if (horizontalDist < Math.max(h1[0] + h2[0], h1[2] + h2[2])) {
                        const verticalOverlap = (h1[1] + h2[1]) - Math.abs(verticalDist);
                        if (verticalOverlap < 0.1 && Math.abs(verticalDist) < 0.5) {
                            // Objects are close vertically
                            if (verticalDist > 0.05) {
                                relationships.push({
                                    subject: obj1.id,
                                    predicate: 'on top of',
                                    object: obj2.id
                                });
                            } else if (verticalDist < -0.05) {
                                relationships.push({
                                    subject: obj2.id,
                                    predicate: 'on top of',
                                    object: obj1.id
                                });
                            }
                        }
                    }
                }
            }
            
            console.log('Converted multiscan to scene graph:', objects.length, 'objects,', relationships.length, 'relationships,', Object.keys(attributes).length, 'objects with attributes');
            
            // Create scene graph structure
            return {
                id: sceneId,
                objects: objects,
                relationships: relationships,
                attributes: attributes
            };
        }

        // Global variables
        let scene, camera, renderer, pointCloud, bboxes = [];
        let selectedObjectId = null;
        let highlightedObjectIds = new Map(); // Map of objectId -> color for highlighted related objects
        let sceneGraphData = null;
        let availableScenes = []; // All scenes from both datasets
        let allPredicates = []; // All unique predicates from all scene graphs
        let currentSceneId = null;
        let currentDataset = 'scannet'; // 'scannet', 'multiscan', or '3rscan'
        

        availableScenes = ["02b33dfb-be2b-2d54-92d2-cd012b2b3c40", "02b33e01-be2b-2d54-93fb-4145a709cec5", "095821f7-e2c2-2de1-9568-b9ce59920e29", "0958220d-e2c2-2de1-9710-c37018da1883", "09582212-e2c2-2de1-9700-fa44b14fbded", "09582225-e2c2-2de1-9564-f6681ef5e511", "09582244-e2c2-2de1-956c-357092d949d1", "0958224e-e2c2-2de1-943b-38e36345e2e7", "0988ea72-eb32-2e61-8344-99e2283c2728", "0ad2d382-79e2-2212-98b3-641bf9d552c1", "0ad2d386-79e2-2212-9b40-43d081db442a", "0ad2d38f-79e2-2212-98d2-9b5060e5e9b5", "0ad2d399-79e2-2212-99cf-7a3512734bd7", "0ad2d39b-79e2-2212-99ae-830c292cd079", "0ad2d3a3-79e2-2212-9a51-9094be707ec2", "0cac7536-8d6f-2d13-8dc2-2f9d7aa62dc4", "0cac753c-8d6f-2d13-8e27-e0664fc33bb9", "0cac7540-8d6f-2d13-8eee-36ba2a428e3f", "0cac7549-8d6f-2d13-8d56-b895956f571a", "0cac7558-8d6f-2d13-8fe1-c8af0362735d", "0cac755a-8d6f-2d13-8fed-b1be02f4ef77", "0cac755e-8d6f-2d13-8c6a-c0979ca34a4f", "0cac7564-8d6f-2d13-8cb2-8b01c0a1b3d5", "0cac7574-8d6f-2d13-8db6-4304f437e6d5", "0cac7578-8d6f-2d13-8c2d-bfa7a04f8af3", "0cac7580-8d6f-2d13-8c9d-d45247b5244b", "0cac7584-8d6f-2d13-8df8-c05e4307b418", "0cac7597-8d6f-2d13-8c9c-6f8542021d5c", "0cac759b-8d6f-2d13-8e3b-2e3bc1ee1158", "0cac75a7-8d6f-2d13-8fdc-083ff44d10fb", "0cac75ad-8d6f-2d13-8c74-5de4dfc4affc", "0cac75b1-8d6f-2d13-8c17-9099db8915bc", "0cac75c4-8d6f-2d13-8c37-fcfaf141ae5a", "0cac75c8-8d6f-2d13-8c08-b3c40c58e0f7", "0cac75d0-8d6f-2d13-8c26-d771a31c3f50", "0cac75dc-8d6f-2d13-8d08-9c497bd6acdc", "0cac75f0-8d6f-2d13-8d86-371deca33bb4", "0cac75f4-8d6f-2d13-8c10-ce688f7ac0af", "0cac75f6-8d6f-2d13-8d7b-dc01a394149c", "0cac75fc-8d6f-2d13-8c59-13d52e366f38", "0cac7602-8d6f-2d13-8ca7-c26866c2e42f", "0cac760f-8d6f-2d13-8d9d-2d8df8f8cb6e", "0cac7623-8d6f-2d13-8da0-462e7fc0bea2", "0cac7627-8d6f-2d13-8eac-41764b5f2c5b", "0cac762b-8d6f-2d13-8de2-832a3c07864b", "0cac7635-8d6f-2d13-8ea5-25f4dc197d1d", "0cac763b-8d6f-2d13-8c67-de3d97b48d39", "0cac7642-8d6f-2d13-8f9f-eb19016049fa", "0cac7648-8d6f-2d13-8e30-76663c19baa4", "0cac764c-8d6f-2d13-8fec-15edfc3e53ad", "0cac7654-8d6f-2d13-8e68-ddd1767454ad", "0cac7664-8d6f-2d13-8e1d-b97c9ab20b12", "0cac766c-8d6f-2d13-8cde-44c997b5e8a7", "0cac7676-8d6f-2d13-8f3a-d7bf7f03e721", "0cac767c-8d6f-2d13-8e22-50ba98af68e6", "0cac767e-8d6f-2d13-8d1a-d5e9b184df15", "0cac7680-8d6f-2d13-8e05-f6da6172d239", "0cac768c-8d6f-2d13-8cc8-7ace156fc3e7", "0cf75f4b-564d-23f5-899f-ff97701d3f3b", "0f2f2711-b736-2f71-8c6a-245a9d820a8c", "0f2f271b-b736-2f71-8f3a-e9265463abcb", "10b17936-3938-2467-88ba-ba5fe2debf14", "10b17940-3938-2467-8a7a-958300ba83d3", "10b1795b-3938-2467-88fe-b10cad8913f8", "10b1795f-3938-2467-8aa6-c985377d32fb", "10b17971-3938-2467-8a86-2b42613aa7ec", "13124cad-cec3-27a6-857f-914a832a87c3", "13124cb2-cec3-27a6-8583-cc0a9d6d1a9a", "13124cbe-cec3-27a6-8745-6e02a03494d2", "13124cc0-cec3-27a6-84bd-1f56cb6d11a8", "13124cc2-cec3-27a6-86ad-946fe3a73493", "137a8158-1db5-2cc0-8003-31c12610471e", "1713f852-5300-2104-8658-73b77b66af61", "1776ad7c-4db7-2333-88b3-edb7a9803f6f", "1776ad7e-4db7-2333-89e1-66854e82170c", "185d7423-3698-223c-8879-80ad9339afce", "18d4d91f-7eb5-280e-8757-1eb6f43ecfd2", "18d4d922-7eb5-280e-87bb-af3229fb1f13", "18d4d926-7eb5-280e-87df-199e66f2babd", "1c211546-f201-2d25-862b-6323518ec6e1", "1d233fe8-e280-2b1a-8fac-c3646a1cd64a", "1d233ff6-e280-2b1a-8ed5-3eec62f9bb3f", "1d233ffe-e280-2b1a-8f1e-7ddb66c98d36", "1d234002-e280-2b1a-8c8d-6aafb5b35a24", "1d234004-e280-2b1a-8ec8-560046b9fc96", "1d234006-e280-2b1a-8e34-b2f670259e8d", "1d234010-e280-2b1a-8da8-205855a16b6b", "1d234018-e280-2b1a-8f22-da2b997865e8", "1d23401e-e280-2b1a-8cef-f28df9df2618", "1d234022-e280-2b1a-8cec-e9787bb0d7b2", "1d2f8514-d757-207c-8e40-377957df6f67", "1d2f8516-d757-207c-8e08-5fef80bf34d8", "1dd7209f-2ba0-22d9-8b9e-b5e270b2580f", "1e0ccbe6-9783-2bd7-8d51-ca9e9226bf35", "20c99392-698f-29c5-8439-54bec948ecb1", "20c993a1-698f-29c5-8716-5a937fdd879a", "20c993af-698f-29c5-84b2-972451f94cfb", "20c993b1-698f-29c5-865d-3a86c19acb3b", "20c993b7-698f-29c5-847d-c8cb8a685f5a", "20c993c1-698f-29c5-86b8-50a2a0907e2b", "20c993c5-698f-29c5-8604-3248ede4091f", "20c993c9-698f-29c5-850e-2a93df894437", "20c993cd-698f-29c5-8575-6a18e0e920cc", "210cdba9-9e8d-2832-862b-b37293fcc0e1", "210cdbab-9e8d-2832-85fa-87d12badb00e", "210cdbb2-9e8d-2832-87e5-7e474cf621ea", "22312382-b828-2c09-9267-bad5dd60ac79", "280d8ebb-6cc6-2788-9153-98959a2da801", "283ccff5-107c-24d5-886c-1d3a1319186a", "2a7f9476-080c-26f9-86e9-c7ce1c76fc07", "2e36952b-e133-204c-911e-7644cb34e8b2", "2e36953b-e133-204c-931b-a2cf0f93fed6", "2e36954b-e133-204c-92ad-1a66c6f63e1a", "2e36955d-e133-204c-90da-122ae14d42a3", "2e4a3964-d452-21a0-9de5-4f7895499143", "2ea047d1-aeca-2021-8a44-8ca8d08fe50b", "321c8680-a5a8-2a84-85c2-816a26d59516", "352e9c36-69fb-27a7-889f-69b450a22b74", "352e9c3e-69fb-27a7-8976-a6860f84f876", "352e9c40-69fb-27a7-8a6d-d2ca32644e09", "352e9c46-69fb-27a7-8b1d-bc83c253c676", "352e9c57-69fb-27a7-8bc7-4cf12e417e21", "355465d0-d29b-29f9-94f2-7707ac505bae", "355465d4-d29b-29f9-9550-e366a10d6924", "38770c9d-86d7-27b8-869e-4f713b04f290", "38770ca1-86d7-27b8-8619-ab66f67d9adf", "3b7b33a9-1b11-283e-9b02-e8f35f6ba24c", "3b7b33af-1b11-283e-9abd-170c6329c0e6", "41385827-a238-2435-8320-d8d3eb507f5e", "4138582f-a238-2435-8332-6902542c2823", "41385847-a238-2435-838b-61864922c518", "4138584b-a238-2435-8128-a939fb07c1c8", "41385851-a238-2435-8056-b7d662a97c93", "422885af-192d-25fc-8651-420062adb475", "422885b3-192d-25fc-84c9-9b80eea1752d", "422885bd-192d-25fc-8571-abff2237f383", "422885c3-192d-25fc-844a-645180810bfd", "422885c7-192d-25fc-85f5-67ba0d80ade5", "422885ce-192d-25fc-851a-df2d675a6559", "422885e0-192d-25fc-844a-62e395291839", "422885e5-192d-25fc-871f-83fa4d7af432", "422885e9-192d-25fc-87a9-7013fe4114f2", "4238490c-60a7-271e-9f38-3c651e3b3912", "43b8cae1-6678-2e38-9865-c19c07c25015", "43b8cae9-6678-2e38-9bc2-8c31ab832242", "43b8caed-6678-2e38-98f8-a76f51ef79af", "43b8caf3-6678-2e38-99da-2aeb70cf8e95", "4731976a-f9f7-2a1a-9737-305b709ca37f", "47319770-f9f7-2a1a-9583-5aa0374a4d35", "47319774-f9f7-2a1a-9412-d4a1c89c8aa3", "4731977c-f9f7-2a1a-976c-34c48a84405c", "48005c65-7d67-29ec-85e0-6a925eb15a27", "48699c02-d4a2-2f10-81c3-552d06ffcbb8", "4a9a43d2-7736-2874-874d-d0fad0570e19", "4a9a43d6-7736-2874-84c3-86ec156a3b2d", "4a9a43e0-7736-2874-87ac-c589da4d0f00", "4a9a43e4-7736-2874-8479-0e81135ccdb0", "4acaebba-6c10-2a2a-8650-34c2f160db99", "4acaebc0-6c10-2a2a-852e-0226d6539299", "4acaebcc-6c10-2a2a-858b-29c7e4fb410d", "4d3d829e-8cf4-2e04-8318-b76f02d91c93", "4d3d82a2-8cf4-2e04-810b-7634c83eed98", "4d3d82a6-8cf4-2e04-828b-ceb5235b58a8", "4d3d82b0-8cf4-2e04-80a8-c955ea964c2f", "4d3d82b6-8cf4-2e04-830a-4303fa0e79c7", "4d3d82bc-8cf4-2e04-8007-e2f7fe679737", "4e858c81-fd93-2cb4-8469-d9226116b5de", "4e858c8f-fd93-2cb4-8676-36cea7ef23cc", "4e858c93-fd93-2cb4-86d6-12f652012a40", "4e858ca1-fd93-2cb4-84b6-490997979830", "4fbad314-465b-2a5d-8445-9d021f278c1e", "4fbad31a-465b-2a5d-8566-f4e4845c1a78", "4fbad31e-465b-2a5d-84b7-c0ddea978db4", "4fbad329-465b-2a5d-8401-a3f550ef3de5", "4fbad32b-465b-2a5d-8499-85100e88f454", "501ebf0b-a3bb-263f-86fd-7ef000a19588", "50e7c0ad-0730-2a5f-8635-252404ee82e0", "5104a9c7-adc4-2a85-9026-45557dcf9a87", "531cff02-0021-28f6-8deb-a71f6c628346", "531cff06-0021-28f6-8ce2-e13a4801e5a8", "531cff08-0021-28f6-8e08-ba2eeb945e09", "5341b79f-8a66-2cdd-84d5-6dba6525dd75", "5341b7bf-8a66-2cdd-8794-026113b7c312", "5341b7c1-8a66-2cdd-853b-598d8f2780ce", "5341b7c3-8a66-2cdd-8651-225a7489523a", "5341b7d3-8a66-2cdd-8633-0a3da632befa", "5341b7d9-8a66-2cdd-844b-cfdadb69ed63", "5341b7db-8a66-2cdd-85c5-66dbe881bd5f", "5341b7dd-8a66-2cdd-8789-886081e65f53", "5341b7e1-8a66-2cdd-87a3-02aad508ff86", "5341b7e3-8a66-2cdd-8709-66a2159f0017", "5341b7e9-8a66-2cdd-86a9-62cf7da55c0a", "54b263a3-0199-2df4-87db-40539528902d", "55551077-36f1-29c0-89ec-2e7690991cb2", "5555107f-36f1-29c0-8903-9b66fb2301d0", "5555108d-36f1-29c0-8b37-5efa2bef59d4", "5630cfc9-12bf-2860-84ed-5bb189f0e94e", "5630cfcb-12bf-2860-87ee-b4e4a5bf0cb0", "5630cfcd-12bf-2860-87f0-65937859709c", "5630cfcf-12bf-2860-8784-83d28a611a83", "569d8f05-72aa-2f24-899c-58b243c8189d", "569d8f09-72aa-2f24-887c-26497a35f26a", "569d8f0d-72aa-2f24-8ac6-c6ee8d927c4b", "569d8f13-72aa-2f24-8b64-3bde3b0603ab", "56d957ed-0184-2301-8f4f-616c3b537e45", "5ed77dd8-c4f5-27a0-85c7-c9cfc4feb6dd", "634b2181-f5d0-2fb7-8547-fd27b0795137", "634d11d3-6833-255d-8cb0-12c4fb3ea031", "634d11d5-6833-255d-8d0a-c0da83387d01", "63b87cf1-ef3f-28f2-871a-c1551f129ce6", "68bae76e-3567-2f7c-82bd-a09641695364", "68bae772-3567-2f7c-804c-d77a47cdc508", "6993478e-1286-2e5b-82d0-eb36d75214de", "6a360523-fa53-2915-9506-4b95fa02cc56", "6a36052d-fa53-2915-9764-30d81b2cc2b5", "6a36054b-fa53-2915-946e-4ec15f811f6e", "6a360567-fa53-2915-9617-da8aa432752d", "6bde6043-9162-246f-8e11-613aba0df55c", "6bde604b-9162-246f-8fb2-2dea80e7fb4c", "6bde6053-9162-246f-8d5d-54e5e3dd721d", "6bde6055-9162-246f-8f44-e3efc21c9e14", "6bde605b-9162-246f-8f73-3a0e3627db01", "6bde6070-9162-246f-8ea9-c8bbe5d7133a", "6bde6079-9162-246f-8fad-d8f2358bd413", "6bde6081-9162-246f-8c4e-ffaf709d17b1", "6bde608d-9162-246f-8dde-3f158d134d50", "6bde6091-9162-246f-8ea8-fdfd6c0a7f77", "6bde609b-9162-246f-8f90-c3d2444a5ab8", "6bde609d-9162-246f-8e6e-a3f462f77042", "6bde60a3-9162-246f-8ca3-48f7e86e95b8", "6bde60a9-9162-246f-8f1a-2441db12c4d1", "6bde60ba-9162-246f-8eaf-b462f3cf6234", "6bde60c0-9162-246f-8d1f-32543babecfb", "6bde60cb-9162-246f-8cf5-d04f7426e56f", "6bde60d8-9162-246f-8f11-834bec23f91e", "6bde60e0-9162-246f-8df9-b07dc8fa8ddf", "6bde60e6-9162-246f-8d7f-823d12b5e358", "6ed38500-7db9-2d45-810c-865e82827b54", "7272e161-a01b-20f6-8b5a-0b97efeb6545", "73315a2b-185c-2c8a-8772-fe23ddd2f531", "73315a2d-185c-2c8a-87e9-d8dfe07ae3cb", "742e8f15-be0a-294e-9ebb-6c72dbcb9662", "751a559f-fe61-2c3b-8cec-258075450954", "751a55a1-fe61-2c3b-8df5-925bfeac2496", "751a55a3-fe61-2c3b-8d1b-daad80d1af30", "751a55a5-fe61-2c3b-8d49-350e8169e05e", "751a55a7-fe61-2c3b-8caa-1aa9dfb86ece", "752cc57f-920c-26f5-8e8d-1f9d567cffd7", "752cc595-920c-26f5-8d66-d08f8f111c92", "75c25973-9ca2-2844-96f4-90cd531364ac", "75c25975-9ca2-2844-9769-84677f46d4cf", "77361fbc-d054-2a22-8bd1-20da69ee28dc", "77361fc2-d054-2a22-8ae5-c56022c5e974", "77361fc6-d054-2a22-8971-e4faf5504a44", "77361fca-d054-2a22-8974-547ca1fbb90f", "77361fce-d054-2a22-8bb2-a870ab051854", "77361fd0-d054-2a22-8b5a-9d2acada2031", "7747a506-9431-24e8-87d9-37a5654d41f4", "7747a50a-9431-24e8-85c6-3488c128ac26", "7747a50c-9431-24e8-877d-e60c3a341cc2", "7747a51f-9431-24e8-8720-19e267b3b828", "77941460-cfdf-29cb-86c7-1f60e2ecd07a", "7ab2a9c9-ebc6-2056-89b6-c78dbb4290d3", "7ab2a9d1-ebc6-2056-8880-07b5c7404d58", "7f30f368-42f9-27ed-852b-e6cfc067acea", "80b8588f-4a8d-222f-8712-eaa02a5450a9", "87e6cf71-9d1a-289f-8510-bddeda7aaad8", "87e6cf7b-9d1a-289f-8692-57e5757dac99", "8e0f1c28-9e28-2339-8584-ff06ff93c341", "8eabc414-5af7-2f32-8797-72769173455b", "8eabc426-5af7-2f32-87bb-a16609b099e3", "8eabc42c-5af7-2f32-87c4-bf646779aa62", "8eabc435-5af7-2f32-85c3-163c1fa6e280", "8eabc43a-5af7-2f32-85d7-b62167a48e58", "8eabc44b-5af7-2f32-8553-18fd693ab49f", "8eabc451-5af7-2f32-87b5-026aa18e3190", "8eabc45a-5af7-2f32-85ed-572ae21920df", "8eabc45f-5af7-2f32-8528-640861d2a135", "8eabc469-5af7-2f32-840f-c1be88e46c62", "8f0f1437-55de-28ce-828e-dbf210a7f472", "8f0f144b-55de-28ce-8053-2828b87a0cc9", "8f0f1467-55de-28ce-8331-b670a7274af9", "95be45d9-a558-22da-9d6f-3d380c02f40e", "95be45db-a558-22da-9eac-5cea5debfcd8", "9c27de4d-6184-2cda-80c6-174eddb07154", "9c27de4f-6184-2cda-81d6-9c806607918e", "a0905fd9-66f7-2272-9dfb-0483fdcc54c7", "a0905fea-66f7-2272-9d2c-15612116fe96", "a0905fee-66f7-2272-9d07-032a9a4e7cc9", "a0905ff2-66f7-2272-9ec9-303aefe3713c", "a0905ffa-66f7-2272-9ca9-24c7ec00f34f", "a0905ffc-66f7-2272-9f05-966bab3ce8ad", "a0906006-66f7-2272-9e46-51000ffe6623", "a090600e-66f7-2272-9cfe-63b80d55da17", "a38a57d8-8a91-2e91-9237-0f8c220feef5", "a38a57de-8a91-2e91-90b2-910244171e92", "a644cb97-0ee5-2f66-9cc7-3ecaa29c19df", "a644cb9b-0ee5-2f66-9ee4-52027f9ba7d5", "a895258d-9035-254b-8e61-2307a9926e62", "a8952595-9035-254b-8c74-9c22ced19216", "ab835f7d-54c6-29a1-9aae-bf97735dd235", "ab835f92-54c6-29a1-99eb-63169a21d553", "ab835f9d-54c6-29a1-9aa1-f481b67b4a6d", "ab835fa7-54c6-29a1-997b-3804159c15ea", "ab835fae-54c6-29a1-995e-b06cfc555786", "ad408c8f-84db-2095-8a45-03100fbc4f86", "ad408c99-84db-2095-8b23-0a011526b47b", "ad408c9d-84db-2095-89c7-8a54f6260252", "ad408cb3-84db-2095-8930-d8244e349008", "ae73fa17-5a60-2398-86e8-aa1145c0c9b7", "b05fdd66-fca0-2d4f-88bb-210da4439475", "b05fdd8a-fca0-2d4f-8ac5-f6ae697787f5", "b05fdd92-fca0-2d4f-89dd-723db1a8d78c", "b05fdd96-fca0-2d4f-88c3-d9dfda85c00e", "b05fdda6-fca0-2d4f-8973-9f8a5cdac3ad", "b05fddcf-fca0-2d4f-8a01-c6bdcc9fba8d", "b05fddd1-fca0-2d4f-8ab9-ecffab72e046", "b05fddd9-fca0-2d4f-8904-936aa0b678e6", "b1cf9968-9fdd-2189-97dd-d5f0d48bf70a", "b1d87fae-e72e-2c8c-9cf3-c927fdb7c685", "b1d87fb0-e72e-2c8c-9f01-25dafeddf472", "b1f23305-d255-2761-95c6-9d89279ef29e", "b1f23308-d255-2761-94da-981d962c6bf8", "b8837e16-57ec-29c6-89c3-0e8b7d668f56", "b8837e28-57ec-29c6-89cf-e1768353440f", "b8837e34-57ec-29c6-8b50-775098de406a", "b8837e3a-57ec-29c6-8b54-d440ca79a11f", "b901681d-e754-293c-8cb3-22aae72dbd42", "ba6fda9c-a4c1-2dca-8185-456923749a4e", "ba6fda9e-a4c1-2dca-8381-c08ad16a6170", "ba6fdaa2-a4c1-2dca-81a8-2aacd785edd7", "ba6fdaaa-a4c1-2dca-8163-a52b18bf6b64", "ba6fdab4-a4c1-2dca-83e2-f5878fdf688a", "baf0a8f0-26d4-2033-8948-52ae41fdd30f", "baf67389-8e94-22f8-8055-1d869ecfede9", "baf6738b-8e94-22f8-8085-24c4e5ef5220", "baf67395-8e94-22f8-8100-9c9d7ce1c2b7", "baf673a6-8e94-22f8-8047-575f7de04f21", "baf673a8-8e94-22f8-837d-d39420725d90", "baf673ac-8e94-22f8-83d4-31a21cc201af", "bcb0fe06-4f39-2c70-9c24-a8dd7496c2f8", "bcb0fe0e-4f39-2c70-9e02-22b2f980cc35", "bcb0fe10-4f39-2c70-9c4e-602f1186d2e9", "bcb0fe17-4f39-2c70-9d19-dafd03e967d8", "bcb0fe1b-4f39-2c70-9f8c-2256ea9752ab", "bcb0fe1f-4f39-2c70-9e7f-a9d783c159fc", "bcb0fe27-4f39-2c70-9dae-5c8625b3553d", "bcb0fe2d-4f39-2c70-9d1a-49a4a6868d7d", "bcb0fe33-4f39-2c70-9cb1-081014d8a9b8", "bf9a3da2-45a5-2e80-8219-1f0a216399fe", "bf9a3dac-45a5-2e80-8073-0fe4e80c0e99", "bf9a3db6-45a5-2e80-825a-e599db74ba26", "bf9a3dba-45a5-2e80-8282-0ee19d0447c7", "bf9a3dc9-45a5-2e80-80cc-29579f2928e6", "bf9a3dcb-45a5-2e80-83df-181fa8da160f", "bf9a3dd3-45a5-2e80-8163-8a5b2573aca4", "bf9a3dd7-45a5-2e80-8330-58904c51c1a9", "bf9a3de7-45a5-2e80-81a4-fd6126f6417b", "bf9a3de9-45a5-2e80-8022-277108d67404", "c12890cc-d3df-2d0d-85cd-eebc3e1c4b62", "c12890d8-d3df-2d0d-87cc-da303a47b893", "c12890da-d3df-2d0d-862f-db6f9df19711", "c6707938-2ecb-2de2-811c-69f6f7a0e638", "c6707946-2ecb-2de2-8381-d5eae12243ee", "c7895f0d-339c-2d13-837c-6e5d8b7be7a8", "c7895f1d-339c-2d13-820f-f998ab956707", "c7895f23-339c-2d13-818e-2375ea0ba6d6", "c7895f27-339c-2d13-836b-c12dca280261", "c7895f35-339c-2d13-805c-47570e126422", "c7895f3e-339c-2d13-832a-b3636f113063", "c7895f42-339c-2d13-814f-994062b318b0", "c7895f46-339c-2d13-81c6-395674134ef2", "c7895f4e-339c-2d13-80d3-90eaa1403a25", "c7895f5f-339c-2d13-82db-e99a08b5f679", "c7895f6f-339c-2d13-830a-81f71c3bfb78", "c7895f74-339c-2d13-8030-f7f2f8504589", "c7895f7c-339c-2d13-819f-3bb0b26c91f6", "c7895f86-339c-2d13-82c8-3976988cd327", "c7895f8f-339c-2d13-81a3-84bc18b475b5", "c92fb576-f771-2064-845a-a52a44a9539f", "c92fb586-f771-2064-8678-a16eca03ac79", "c92fb58e-f771-2064-85ec-a3446ebee692", "c92fb594-f771-2064-879b-cc598a9dabe5", "c92fb59e-f771-2064-8431-6a20d3396067", "c92fb5b3-f771-2064-86f2-f14da264bfcf", "c92fb5b5-f771-2064-8570-dbe16cb33764", "c9fb7aa5-2a5b-2cf7-902e-42a0339c7242", "cdcaf5c1-ddd8-2ed6-9553-bcaa06ad43da", "cf00577c-b8f0-2aa8-869e-175d8b655d12", "d63767be-3205-226c-9a89-3a27969053a7", "d63767c3-3205-226c-98c2-fdccc047d36e", "d7d40d39-7a5d-2b36-972e-a7c800ca7bbf", "d7d40d3e-7a5d-2b36-97b3-dd11abc0e876", "d7d40d48-7a5d-2b36-97ad-692c9b56b508", "d7d40d4e-7a5d-2b36-97e7-34324c52ac42", "d7d40d5c-7a5d-2b36-9433-ee98b893988d", "d7d40d62-7a5d-2b36-955e-86a394caeabb", "d7d40d6c-7a5d-2b36-9674-c435fa58a2d1", "d9725be1-7513-2d91-8723-770169ff5b75", "dbeb4cee-faf9-2324-991e-79c1f7e0b908", "dbeb4d09-faf9-2324-9b85-dabd70dba4d0", "dbeb4d1b-faf9-2324-9ac8-cbad7aa51d12", "dc42b37a-8d5c-2d2a-84dd-83aff10e0abe", "ddc73797-765b-241a-9e2c-097c5989baf6", "ddc737a5-765b-241a-9cd2-c6e7a89aa43d", "ddc737a7-765b-241a-9f27-0958b929deb5", "ddc737ad-765b-241a-9d9f-1f19fab18318", "ddc737b1-765b-241a-9c21-a4e2674b2853", "def7fbc1-48c2-2895-91d9-cb5e6f3e3589", "e3004a81-9f2a-2778-874e-fa76b0e67096", "e44d238f-52a2-2879-88ec-e383a4d9abf3", "e48c48f4-8b2f-2858-88c2-fd5e4c33f5b8", "e61b0e04-bada-2f31-82d6-72831a602ba7", "ebc42044-82a4-2113-8789-1c8c8bb7cbcd", "eee5b056-ee2d-28f4-9bbe-f7ddf37895a6", "f38169c7-378c-2a65-8543-3c7481e856fe", "f4f31600-8408-2255-971c-b8c20605563a", "f62fd5f4-9a3f-2f44-8b81-246b93170189", "f62fd5f8-9a3f-2f44-8b1e-1289a3a61e26", "f62fd5fd-9a3f-2f44-883a-1e5cf819608e", "f62fd5ff-9a3f-2f44-894c-462b3997d695", "fcf66d7b-622d-291c-86b8-7db96aebcee3", "fcf66d94-622d-291c-85fc-284b68d64c81", "fcf66da6-622d-291c-8685-46cd96a8af4e", "fcf66daa-622d-291c-8548-a1163ee299b4", "fcf66dac-622d-291c-8542-d108fb4a91f5", "fcf66db2-622d-291c-8493-4f2517282f3f", "fcf66dba-622d-291c-8537-1ab5313bc52a", "feefd90b-9d00-2ce5-8119-b936443cc39b", "scene0000_00", "scene0001_00", "scene0002_00", "scene0003_00", "scene0004_00", "scene0005_00", "scene0006_00", "scene0007_00", "scene0008_00", "scene0009_00", "scene0010_00", "scene0011_00", "scene0012_00", "scene0013_00", "scene0014_00", "scene0015_00", "scene0016_00", "scene0017_00", "scene0018_00", "scene0019_00", "scene0020_00", "scene0021_00", "scene0022_00", "scene0023_00", "scene0024_00", "scene0025_00", "scene0026_00", "scene0027_00", "scene0028_00", "scene0029_00", "scene0030_00", "scene0031_00", "scene0032_00", "scene0033_00", "scene0034_00", "scene0035_00", "scene0036_00", "scene0037_00", "scene0038_00", "scene0039_00", "scene0040_00", "scene0041_00", "scene0042_00", "scene0043_00", "scene0044_00", "scene0045_00", "scene0046_00", "scene0047_00", "scene0048_00", "scene0049_00", "scene0050_00", "scene0051_00", "scene0052_00", "scene0053_00", "scene0055_00", "scene0056_00", "scene0057_00", "scene0058_00", "scene0059_00", "scene0060_00", "scene0061_00", "scene0062_00", "scene0063_00", "scene0064_00", "scene0065_00", "scene0066_00", "scene0067_00", "scene0068_00", "scene0069_00", "scene0070_00", "scene0071_00", "scene0072_00", "scene0073_00", "scene0074_00", "scene0075_00", "scene0076_00", "scene0077_00", "scene0078_00", "scene0079_00", "scene0080_00", "scene0081_00", "scene0082_00", "scene0083_00", "scene0084_00", "scene0085_00", "scene0086_00", "scene0087_00", "scene0088_00", "scene0089_00", "scene0090_00", "scene0091_00", "scene0093_00", "scene0094_00", "scene0095_00", "scene0096_00", "scene0097_00", "scene0099_00", "scene0100_00", "scene0103_00", "scene0131_00", "scene0139_00", "scene0144_00", "scene0146_00", "scene0149_00", "scene0153_00", "scene0164_00", "scene0169_00", "scene0187_00", "scene0193_00", "scene0196_00", "scene0203_00", "scene0207_00", "scene0208_00", "scene0221_00", "scene0222_00", "scene0231_00", "scene0246_00", "scene0249_00", "scene0251_00", "scene0256_00", "scene0257_00", "scene0277_00", "scene0278_00", "scene0300_00", "scene0304_00", "scene0307_00", "scene0314_00", "scene0316_00", "scene0328_00", "scene0329_00", "scene0334_00", "scene0338_00", "scene0342_00", "scene0343_00", "scene0351_00", "scene0353_00", "scene0354_00", "scene0355_00", "scene0356_00", "scene0357_00", "scene0377_00", "scene0378_00", "scene0382_00", "scene0389_00", "scene0406_00", "scene0412_00", "scene0414_00", "scene0423_00", "scene0426_00", "scene0427_00", "scene0430_00", "scene0432_00", "scene0435_00", "scene0441_00", "scene0458_00", "scene0461_00", "scene0462_00", "scene0474_00", "scene0488_00", "scene0490_00", "scene0494_00", "scene0496_00", "scene0500_00", "scene0518_00", "scene0527_00", "scene0535_00", "scene0549_00", "scene0550_00", "scene0552_00", "scene0553_00", "scene0558_00", "scene0559_00", "scene0565_00", "scene0568_00", "scene0574_00", "scene0575_00", "scene0578_00", "scene0580_00", "scene0583_00", "scene0591_00", "scene0593_00", "scene0595_00", "scene0598_00", "scene0599_00", "scene0606_00", "scene0607_00", "scene0608_00", "scene0609_00", "scene0616_00", "scene0618_00", "scene0621_00", "scene0629_00", "scene0633_00", "scene0643_00", "scene0644_00", "scene0645_00", "scene0647_00", "scene0648_00", "scene0651_00", "scene0652_00", "scene0653_00", "scene0655_00", "scene0658_00", "scene0660_00", "scene0663_00", "scene0664_00", "scene0665_00", "scene0670_00", "scene0671_00", "scene0678_00", "scene0684_00", "scene0685_00", "scene0686_00", "scene0689_00", "scene0690_00", "scene0693_00", "scene0695_00", "scene0696_00", "scene0697_00", "scene0699_00", "scene0700_00", "scene0701_00", "scene0702_00", "scene0704_00", "scene_00002_00", "scene_00004_00", "scene_00007_00", "scene_00023_00", "scene_00052_00", "scene_00078_00", "scene_00084_00"];
        allPredicates = ["above", "below", "contains", "embedded in", "embeds", "far from", "hanging on", "has", "higher than", "in", "in between", "in center of", "in corner of", "inside", "is aligned with", "leaning on", "lower than", "near", "next to", "of", "on", "over", "supports", "under"];
        // Detect dataset from scene ID pattern
        function getDatasetFromSceneId(sceneId) {
            // MultiScan scenes use underscore after "scene": scene_00000_00
            // ScanNet scenes don't: scene0000_00
            // 3RScan scenes use UUIDs: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
            if (sceneId.startsWith('scene_')) {
                return 'multiscan';
            } else if (sceneId.startsWith('scene')) {
                return 'scannet';
            } else {
                // UUID pattern for 3RScan
                return '3rscan';
            }
        }
        let showAllBboxes = false;
        let relationshipLines = []; // Lines connecting related objects
        
        // Annotation mode: null, 'similarity', 'attribute', 'relationship'
        let annotationMode = null;
        let annotationFirstObject = null;
        let similarityAnnotations = []; // Array of {id1, id2, label1, label2, timestamp}
        let annotationLines = [];
        let previewedCandidateId = null;
        
        // Attribute validation
        let attributeValidations = {}; // Map of attribute_id -> 'correct' | 'incorrect' | null
        
        // Added attribute annotations
        let additionalAttributes = []; // Array of {id, object_id, name, timestamp}
        
        // Relationship validation
        let relationshipValidations = {}; // Map of relationship index -> 'correct' | 'incorrect' | null
        
        // Added relationship annotations
        let additionalRelationships = []; // Array of {id, subject_id, object_id, predicate, timestamp}
        
        // Color palette for highlighted objects
        const highlightColors = [
            { hex: 0xffa726, css: '#ffa726', border: '#ff6f00', name: 'orange' },
            { hex: 0x42a5f5, css: '#42a5f5', border: '#1976d2', name: 'blue' },
            { hex: 0xec407a, css: '#ec407a', border: '#c2185b', name: 'pink' },
            { hex: 0xab47bc, css: '#ab47bc', border: '#7b1fa2', name: 'purple' },
            { hex: 0x26a69a, css: '#26a69a', border: '#00796b', name: 'teal' },
            { hex: 0xffca28, css: '#ffca28', border: '#f57f17', name: 'yellow' },
            { hex: 0x66bb6a, css: '#66bb6a', border: '#388e3c', name: 'green' },
            { hex: 0xff7043, css: '#ff7043', border: '#d84315', name: 'deep-orange' }
        ];
        let nextColorIndex = 0;
        
        // Filters
        let selectedAttributeFilters = new Set();
        let selectedRelTypeFilters = new Set();

        // Initialize Three.js
        function initViewer() {
            const container = document.getElementById('viewer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Basic lighting for textured meshes (OBJ/MTL materials need lights)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-5, -6, -4);
            scene.add(fillLight);

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.up.set(0, 0, 1);  // Set Z-up coordinate system for proper rotation
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // Add OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.1;
            controls.maxDistance = 1000;
            // No maxPolarAngle constraint - allow free rotation around all axes

            // Handle window resize
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) {
                controls.update();
            }
            renderer.render(scene, camera);
        }

        // Load scene graph JSON
        document.getElementById('scene-graph-file').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const status = document.getElementById('sg-status');
            status.textContent = 'Loading...';
            status.className = 'file-status';

            try {
                const text = await file.text();
                sceneGraphData = JSON.parse(text);
                status.textContent = `Loaded: ${file.name}`;
                status.className = 'file-status loaded';
                
                // Clear filters when loading new scene
                selectedAttributeFilters.clear();
                selectedRelTypeFilters.clear();
                updateAttributeFilterChips();
                updateRelTypeFilterChips();
                document.getElementById('clear-object-filters').style.display = 'none';
                document.getElementById('clear-rel-filters').style.display = 'none';
                
                initializeFilters();
                updateSceneInfo();
                loadBoundingBoxes();
                updateObjectsList();
                
                // Clear all validations and annotations for new scene
                attributeValidations = {};
                additionalAttributes = [];
                relationshipValidations = {};
                additionalRelationships = [];
                updateValidationStats();
                
                // Try to load point cloud if already loaded
                const plyFile = document.getElementById('ply-file').files[0];
                if (plyFile) {
                    loadPointCloudFile(plyFile);
                }
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                status.className = 'file-status';
                console.error('Error loading scene graph:', error);
            }
        });

        // Load PLY file
        document.getElementById('ply-file').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const status = document.getElementById('ply-status');
            status.textContent = 'Loading...';
            status.className = 'file-status';

            try {
                await loadPointCloudFile(file);
                status.textContent = `Loaded: ${file.name}`;
                status.className = 'file-status loaded';
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                status.className = 'file-status';
                console.error('Error loading PLY:', error);
            }
        });

        function disposeObject(object) {
            if (!object) return;
            object.traverse(child => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m && m.dispose && m.dispose());
                    } else if (child.material.dispose) {
                        child.material.dispose();
                    }
                }
                if (child.texture && child.texture.dispose) {
                    child.texture.dispose();
                }
            });
        }

        async function loadTexturedMesh(candidate) {
            // candidate: { obj, mtl }
            const resourcePath = candidate.obj.substring(0, candidate.obj.lastIndexOf('/') + 1);
            console.log('Attempting textured mesh load:', candidate.obj);

            // Remove existing geometry
            if (pointCloud) {
                scene.remove(pointCloud);
                disposeObject(pointCloud);
            }

            let materials = null;
            if (candidate.mtl) {
                const mtlLoader = new THREE.MTLLoader();
                mtlLoader.setResourcePath(resourcePath);
                mtlLoader.setPath(resourcePath);
                materials = await new Promise((resolve, reject) => {
                    mtlLoader.load(candidate.mtl.replace(resourcePath, ''), resolve, undefined, reject);
                });
                materials.preload();
            }

            const objLoader = new THREE.OBJLoader();
            if (materials) objLoader.setMaterials(materials);
            objLoader.setPath(resourcePath);
            objLoader.setResourcePath(resourcePath); // for texture lookups referenced in OBJ/MTL
            const object = await new Promise((resolve, reject) => {
                objLoader.load(candidate.obj.replace(resourcePath, ''), resolve, undefined, reject);
            });

            pointCloud = object;

            // Ensure materials render in current lighting and show both sides
            pointCloud.traverse(node => {
                if (node.isMesh) {
                    if (node.material) {
                        const mats = Array.isArray(node.material) ? node.material : [node.material];
                        mats.forEach(m => {
                            if (!m) return;
                            m.side = THREE.DoubleSide;
                            if ('map' in m && m.map) {
                                m.map.encoding = THREE.sRGBEncoding;
                            } else if (!m.color || (m.color.r === 0 && m.color.g === 0 && m.color.b === 0)) {
                                // Default to a mid-gray if no texture/color
                                m.color = new THREE.Color(0x888888);
                            }
                            m.needsUpdate = true;
                        });
                    } else {
                        node.material = new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.DoubleSide });
                    }
                }
            });

            // Hide point size control for mesh
            const pointSizeControl = document.getElementById('point-size-control');
            if (pointSizeControl) pointSizeControl.style.display = 'none';

            // Ensure the visibility toggle stays in sync
            const showPointsCheckbox = document.getElementById('show-points');
            if (showPointsCheckbox) showPointsCheckbox.checked = true;

            scene.add(pointCloud);
            console.log('Textured mesh added to scene from', candidate.obj);
        }

        async function loadPointCloudFile(file) {
            document.getElementById('loading').classList.remove('hidden');
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pcData = await parsePLY(arrayBuffer);
                
                // Sample if too many points (only if no faces, as sampling would break face indices)
                if (!pcData.hasFaces) {
                    const maxPoints = 200000;
                    const numVertices = pcData.points.length / 3;
                    if (numVertices > maxPoints) {
                        console.log('Sampling point cloud from', numVertices, 'to', maxPoints, 'points');
                        const step = Math.floor(numVertices / maxPoints);
                        const sampledPoints = [];
                        const sampledColors = [];
                        for (let v = 0; v < numVertices; v += step) {
                            const idx = v * 3;
                            sampledPoints.push(pcData.points[idx], pcData.points[idx+1], pcData.points[idx+2]);
                            if (pcData.hasColors && pcData.colors) {
                                const colorIdx = v * 3;
                                sampledColors.push(pcData.colors[colorIdx], pcData.colors[colorIdx+1], pcData.colors[colorIdx+2]);
                            }
                        }
                        pcData.points = sampledPoints;
                        pcData.colors = sampledColors;
                        console.log('Sampled to', sampledPoints.length / 3, 'points');
                    }
                }
                
                loadPointCloud(pcData);
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        function loadPointCloud(data) {
            // Remove existing point cloud/mesh
            if (pointCloud) {
                scene.remove(pointCloud);
                disposeObject(pointCloud);
            }

            const points = data.points;
            console.log('Loading 3D model with', points.length / 3, 'vertices, hasFaces:', data.hasFaces);
            
            if (!points || points.length === 0) {
                console.error('No points data provided');
                return;
            }

            // Validate positions - check for NaN and replace with 0
            for (let i = 0; i < points.length; i++) {
                if (isNaN(points[i]) || !isFinite(points[i])) {
                    points[i] = 0;
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));

            let material;
            
            // Use mesh if faces are available, otherwise use points
            if (data.hasFaces && data.indices && data.indices.length > 0) {
                console.log('Rendering as mesh with', data.indices.length / 3, 'faces');
                // Validate indices are within vertex range
                const maxIndex = (points.length / 3) - 1;
                const validIndices = [];
                for (let i = 0; i < data.indices.length; i++) {
                    const idx = data.indices[i];
                    if (idx >= 0 && idx <= maxIndex) {
                        validIndices.push(idx);
                    }
                }
                if (validIndices.length > 0) {
                    geometry.setIndex(validIndices);
                    geometry.computeVertexNormals();
                } else {
                    console.warn('No valid face indices found, rendering as point cloud instead');
                    data.hasFaces = false;
                }
                
                if (data.hasColors && data.colors && data.colors.length > 0) {
                    console.log('Using colored mesh, color count:', data.colors.length);
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(data.colors, 3));
                    material = new THREE.MeshBasicMaterial({ 
                        vertexColors: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    console.log('Using grayscale mesh');
                    material = new THREE.MeshBasicMaterial({ 
                        color: 0x888888,
                        side: THREE.DoubleSide
                    });
                }
                
                pointCloud = new THREE.Mesh(geometry, material);
                // Hide point size control for mesh
                const pointSizeControl = document.getElementById('point-size-control');
                if (pointSizeControl) pointSizeControl.style.display = 'none';
                // Update label
                const showPointsLabel = document.querySelector('label[for="show-points"]');
                if (showPointsLabel) showPointsLabel.innerHTML = '<input type="checkbox" id="show-points" checked> Show Mesh';
            } else {
                console.log('Rendering as point cloud (no faces)');
                // Show point size control for point cloud
                const pointSizeControl = document.getElementById('point-size-control');
                if (pointSizeControl) pointSizeControl.style.display = 'block';
                // Update label
                const showPointsLabel = document.querySelector('label[for="show-points"]');
                if (showPointsLabel) showPointsLabel.innerHTML = '<input type="checkbox" id="show-points" checked> Show Point Cloud';
                // Use reasonable point size - larger for better visibility
                const pointSize = 8.0; // Larger size for better visibility with attenuation
                if (data.hasColors && data.colors && data.colors.length > 0) {
                    console.log('Using colored point cloud, color count:', data.colors.length);
                    // Colors are already in 0-1 range from PLY parser
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(data.colors, 3));
                    material = new THREE.PointsMaterial({ 
                        size: pointSize, 
                        vertexColors: true,
                        sizeAttenuation: true
                    });
                    console.log('Point cloud material with vertex colors created');
                } else {
                    console.log('Using grayscale point cloud');
                    material = new THREE.PointsMaterial({ 
                        size: pointSize, 
                        color: 0x888888,
                        sizeAttenuation: true
                    });
                }
                
                pointCloud = new THREE.Points(geometry, material);
            }
            
            // Don't apply transformation to mesh - bounding boxes are already in mesh coordinates
            // The axis alignment is already baked into the scene graph annotations
            
            scene.add(pointCloud);
            console.log('3D model added to scene. Scene has', scene.children.length, 'children');
            console.log('Mesh/Points visible:', pointCloud.visible, 'vertices:', pointCloud.geometry.attributes.position.count);

            // Manually compute bounds from valid positions only
            // Exclude vertices that are exactly 0,0,0 (likely replaced NaN values)
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            let validPointCount = 0;
            
            for (let i = 0; i < points.length; i += 3) {
                const x = points[i];
                const y = points[i + 1];
                const z = points[i + 2];
                // Check if point is valid AND not a replaced NaN (0,0,0 or suspiciously large)
                // Use 100 meter threshold - appropriate for room-scale 3D scans
                // Values like 4294.97 (2^32/1e6) indicate data encoding issues
                const isValid = isFinite(x) && isFinite(y) && isFinite(z) &&
                               !(x === 0 && y === 0 && z === 0) &&
                               Math.abs(x) < 100 && Math.abs(y) < 100 && Math.abs(z) < 100;
                
                if (isValid) {
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                    validPointCount++;
                }
            }
            
            if (validPointCount === 0) {
                console.error('No valid points found!');
                return;
            }
            
            const center = new THREE.Vector3((minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2);
            const size = new THREE.Vector3(maxX - minX, maxY - minY, maxZ - minZ);
            const maxDim = Math.max(size.x, size.y, size.z);
            
            console.log('Model bounds:');
            console.log('  Center: [', center.x.toFixed(2), ',', center.y.toFixed(2), ',', center.z.toFixed(2), ']');
            console.log('  Size: [', size.x.toFixed(2), ',', size.y.toFixed(2), ',', size.z.toFixed(2), ']');
            console.log('  MaxDim:', maxDim.toFixed(2));
            console.log('  Valid points:', validPointCount, '/', points.length / 3);
            
            // Set camera target and position for OrbitControls (Z-up coordinate system)
            if (controls && isFinite(maxDim) && maxDim > 0) {
                controls.target.copy(center);
                const distance = maxDim * 2.5;
                // Position camera for Z-up: elevated in Z, offset in X and Y
                camera.position.set(center.x + distance, center.y + distance * 0.7, center.z + distance * 0.5);
                controls.update();
                console.log('Camera set to:', camera.position.x.toFixed(2), camera.position.y.toFixed(2), camera.position.z.toFixed(2));
                console.log('Looking at:', center.x.toFixed(2), center.y.toFixed(2), center.z.toFixed(2));
            } else {
                console.error('Could not set camera position! maxDim:', maxDim, 'isFinite:', isFinite(maxDim));
            }
        }

        function createBoundingBox(bbox) {
            const center = new THREE.Vector3(...bbox.center);
            const halfDims = new THREE.Vector3(...bbox.half_dims);
            const rot = bbox.rotation;

            if (bbox.object_id < 3) {
                console.log('Creating bbox', bbox.object_id, 'at [', center.x.toFixed(2), center.y.toFixed(2), center.z.toFixed(2), '] dims: [', halfDims.x.toFixed(2), halfDims.y.toFixed(2), halfDims.z.toFixed(2), ']');
            }

            const geometry = new THREE.BoxGeometry(
                halfDims.x * 2,
                halfDims.y * 2,
                halfDims.z * 2
            );

            // Use EdgesGeometry for clean, thick lines
            const edges = new THREE.EdgesGeometry(geometry);
            
            const material = new THREE.LineBasicMaterial({
                color: 0xff0000,
                linewidth: 3, // Note: linewidth > 1 may not work on all platforms, but we'll set it anyway
                transparent: true,
                opacity: 0.8
            });

            const box = new THREE.LineSegments(edges, material);
            box.position.copy(center);
            
            // Handle quaternion - ScanNet uses [x, y, z, w] format
            const quaternion = new THREE.Quaternion();
            if (rot && rot.length === 4) {
                // ScanNet format is [x, y, z, w]
                quaternion.set(rot[0], rot[1], rot[2], rot[3]);
                quaternion.normalize();
                
                if (bbox.object_id < 3) {
                    console.log('Bbox', bbox.object_id, 'quaternion:', rot, 'normalized:', quaternion.x.toFixed(3), quaternion.y.toFixed(3), quaternion.z.toFixed(3), quaternion.w.toFixed(3));
                }
            } else {
                quaternion.set(0, 0, 0, 1); // Identity quaternion
            }
            
            box.setRotationFromQuaternion(quaternion);
            box.userData.objectId = bbox.object_id;

            return box;
        }

        function loadBoundingBoxes() {
            if (!sceneGraphData || !sceneGraphData.objects) return;

            // Remove existing bboxes
            bboxes.forEach(bbox => {
                scene.remove(bbox);
                bbox.geometry.dispose();
                bbox.material.dispose();
            });
            bboxes = [];

            sceneGraphData.objects.forEach(obj => {
                const bbox = obj.bbox;
                if (bbox) {
                    const box = createBoundingBox({
                        center: bbox.center,
                        half_dims: bbox.half_dims,
                        rotation: bbox.rotation,
                        object_id: obj.id
                    });
                    bboxes.push(box);
                    // Don't add to scene by default - only show on selection or when "Show All" is checked
                }
            });
        }

        function updateSceneInfo() {
            if (!sceneGraphData) return;
            
            const info = `Scene ID: ${sceneGraphData.id || 'Unknown'}<br>
                Objects: ${sceneGraphData.objects ? sceneGraphData.objects.length : 0}<br>
                Relationships: ${sceneGraphData.relationships ? sceneGraphData.relationships.length : 0}<br>
                Attributes: ${sceneGraphData.attributes ? Object.keys(sceneGraphData.attributes).length : 0}`;
            
            document.getElementById('scene-summary').innerHTML = info;
        }

        function updateObjectsList() {
            if (!sceneGraphData || !sceneGraphData.objects) return;

            const container = document.getElementById('objects-container');
            container.innerHTML = '';
            
            let displayedCount = 0;
            let totalCount = sceneGraphData.objects.length;

            sceneGraphData.objects.forEach(obj => {
                // Apply filters
                if (!objectMatchesFilters(obj)) return;
                displayedCount++;
                
                const div = document.createElement('div');
                div.className = 'object-item';
                div.dataset.objectId = obj.id;
                
                // Get attributes for this object (predicted)
                let attributesHTML = '<div class="object-attributes">';
                let hasAttributes = false;
                
                if (sceneGraphData.attributes && sceneGraphData.attributes.length > 0) {
                    const objAttributes = sceneGraphData.attributes.filter(attr => attr.object_id === obj.id);
                    if (objAttributes.length > 0) {
                        hasAttributes = true;
                        objAttributes.forEach(attr => {
                            const validation = attributeValidations[attr.id];
                            const validationClass = validation === 'correct' ? 'validated-correct' : 
                                                   validation === 'incorrect' ? 'validated-incorrect' : '';
                            // Only show validation buttons in attribute mode
                            const validationBtnsHTML = annotationMode === 'attribute' ? `
                                    <span class="attr-validation-btns">
                                        <button class="attr-validation-btn correct ${validation === 'correct' ? 'active' : ''}" 
                                                onclick="validateAttribute('${attr.id}', 'correct', event)" 
                                                title="Mark as correct">‚úì</button>
                                        <button class="attr-validation-btn incorrect ${validation === 'incorrect' ? 'active' : ''}" 
                                                onclick="validateAttribute('${attr.id}', 'incorrect', event)" 
                                                title="Mark as incorrect">‚úó</button>
                                    </span>` : '';
                            attributesHTML += `
                                <span class="attribute-tag ${validationClass}" data-attr-id="${attr.id}">
                                    <span class="attr-name">${attr.name}</span>
                                    ${validationBtnsHTML}
                                </span>`;
                        });
                    }
                }
                
                // Get added attributes for this object
                const objAnnotatedAttrs = additionalAttributes.filter(attr => attr.object_id === obj.id);
                if (objAnnotatedAttrs.length > 0) {
                    hasAttributes = true;
                    objAnnotatedAttrs.forEach(attr => {
                        // Only show delete button in attribute mode
                        const deleteBtnHTML = annotationMode === 'attribute' ? 
                            `<button class="attr-delete-btn" onclick="deleteAnnotatedAttribute('${attr.id}', event)" title="Remove">√ó</button>` : '';
                        attributesHTML += `
                            <span class="attribute-tag annotated-added" data-annotated-attr-id="${attr.id}">
                                <span class="attr-name">${attr.name}</span>
                                ${deleteBtnHTML}
                            </span>`;
                    });
                }
                
                attributesHTML += '</div>';
                
                // Add attribute annotation form - only in attribute mode
                const addAttrHTML = annotationMode === 'attribute' ? `
                    <button class="toggle-add-attr-btn" onclick="toggleAddAttributeForm(${obj.id}, event)">+ Add Attribute</button>
                    <div class="add-attribute-section hidden" id="add-attr-form-${obj.id}">
                        <div class="add-attr-row">
                            <input type="text" class="add-attr-input" id="attr-name-${obj.id}" placeholder="Attribute name">
                            <button class="add-attr-btn" onclick="addAnnotatedAttribute(${obj.id}, event)">Add</button>
                        </div>
                    </div>
                ` : '';
                
                div.innerHTML = `
                    <div class="object-id">Object ${obj.id}</div>
                    <div class="object-labels">${obj.labels ? obj.labels.join(', ') : 'No labels'}</div>
                    ${hasAttributes ? attributesHTML : '<div class="object-attributes"><em style="color: #999;">No attributes</em></div>'}
                    ${addAttrHTML}
                `;
                div.addEventListener('click', (e) => {
                    // Don't select if clicking on buttons or inputs
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                    selectObject(obj.id);
                });
                container.appendChild(div);
            });
            
            // Show filter status
            if (selectedAttributeFilters.size > 0) {
                const filterInfo = document.createElement('div');
                filterInfo.style.cssText = 'padding: 8px; font-size: 11px; color: #666; background: #f0f0f0; border-radius: 3px; margin-bottom: 8px;';
                filterInfo.textContent = `Showing ${displayedCount} of ${totalCount} objects`;
                container.insertBefore(filterInfo, container.firstChild);
            }
        }

        function selectObject(objectId) {
            selectedObjectId = objectId;
            
            // Update object list selection
            document.querySelectorAll('.object-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.objectId == objectId);
            });
            
            // In similarity mode, show candidates for similar object annotation
            if (annotationMode === 'similarity') {
                highlightedObjectIds.clear();
                showAnnotationCandidates(objectId);
                
                // Highlight selected object in purple
                updateBoundingBoxes();
                const bbox = bboxes.find(b => b.userData.objectId === objectId);
                if (bbox) {
                    bbox.material.color.setHex(0x9c27b0);
                    bbox.material.opacity = 0.9;
                    scene.add(bbox);
                }
                updateRelationshipLines();
                return;
            }
            
            // For attribute/relationship/no mode, show normal relationships
            highlightedObjectIds.clear();
            
            // Update bounding box visibility and appearance
            updateBoundingBoxes();

            // Update relationships display
            updateRelationshipsDisplay(objectId);
            
            // Update lines (only for currently highlighted objects)
            updateRelationshipLines();
        }

        function createSimilarityAnnotation(candidateId, event) {
            if (event) event.stopPropagation();
            if (!selectedObjectId || selectedObjectId === candidateId) return;
            
            const obj1 = sceneGraphData.objects.find(o => o.id === selectedObjectId);
            const obj2 = sceneGraphData.objects.find(o => o.id === candidateId);
            const label1 = obj1 ? (obj1.labels[0] || `Object ${selectedObjectId}`) : `Object ${selectedObjectId}`;
            const label2 = obj2 ? (obj2.labels[0] || `Object ${candidateId}`) : `Object ${candidateId}`;
            
            // Check if same class
            const sameClass = obj1 && obj2 && obj1.labels[0] === obj2.labels[0];
            
            similarityAnnotations.push({
                id1: selectedObjectId,
                id2: candidateId,
                label1: label1,
                label2: label2,
                sameClass: sameClass,
                timestamp: new Date().toISOString()
            });
            
            // Clear preview
            previewedCandidateId = null;
            
            updateAnnotationsDisplay();
            showAnnotationCandidates(selectedObjectId); // Refresh to show updated "annotated" status
            updateAnnotationLines();
        }

        function togglePreviewCandidate(candidateId, event) {
            // Stop event from bubbling
            if (event) event.stopPropagation();
            
            if (previewedCandidateId === candidateId) {
                // Un-preview
                previewedCandidateId = null;
                updateBoundingBoxes();
                // Remove highlight from candidate item
                document.querySelectorAll('.candidate-item').forEach(item => {
                    item.classList.remove('previewing');
                });
            } else {
                // Preview this candidate
                previewedCandidateId = candidateId;
                updateBoundingBoxes();
                
                // Show candidate's bounding box in blue
                const bbox = bboxes.find(b => b.userData.objectId === candidateId);
                if (bbox) {
                    bbox.material.color.setHex(0x42a5f5); // Blue for preview
                    bbox.material.opacity = 0.8;
                    scene.add(bbox);
                }
                
                // Highlight the candidate item
                document.querySelectorAll('.candidate-item').forEach(item => {
                    item.classList.remove('previewing');
                });
                const candidateItem = event?.currentTarget;
                if (candidateItem) {
                    candidateItem.classList.add('previewing');
                }
            }
        }

        function showAnnotationCandidates(firstObjectId) {
            const container = document.getElementById('relationships-container');
            
            if (annotationMode !== 'similarity') {
                // Show normal relationships
                updateRelationshipsDisplay(selectedObjectId);
                return;
            }
            
            if (firstObjectId === null || firstObjectId === undefined) {
                container.innerHTML = '<div style="color: #999; font-size: 12px; padding: 10px;">Select an object from the list to see annotation candidates</div>';
                return;
            }
            
            const firstObj = sceneGraphData.objects.find(o => o.id === firstObjectId);
            if (!firstObj) return;
            
            const firstClass = firstObj.labels[0];
            
            // Get all other objects, prioritize same class
            const candidates = sceneGraphData.objects
                .filter(o => o.id !== firstObjectId)
                .map(o => {
                    const sameClass = o.labels[0] === firstClass;
                    const alreadyAnnotated = similarityAnnotations.some(ann => 
                        (ann.id1 === firstObjectId && ann.id2 === o.id) ||
                        (ann.id2 === firstObjectId && ann.id1 === o.id)
                    );
                    return {
                        id: o.id,
                        label: o.labels[0] || `Object ${o.id}`,
                        sameClass: sameClass,
                        alreadyAnnotated: alreadyAnnotated
                    };
                })
                .sort((a, b) => {
                    // Sort: same class first, then not annotated, then by label
                    if (a.sameClass !== b.sameClass) return b.sameClass ? 1 : -1;
                    if (a.alreadyAnnotated !== b.alreadyAnnotated) return a.alreadyAnnotated ? 1 : -1;
                    return a.label.localeCompare(b.label);
                });
            
            let html = `<div style="font-size: 12px; margin-bottom: 10px; padding: 10px; background: #f3e5f5; border-radius: 4px;">
                <strong>Selected:</strong> ${firstObj.labels[0] || `Object ${firstObjectId}`}<br>
                <span style="font-size: 10px; color: #666;">Click "Mark Similar" to create annotation</span>
            </div>`;
            
            // Show same class first
            const sameClassCandidates = candidates.filter(c => c.sameClass);
            const otherCandidates = candidates.filter(c => !c.sameClass);
            
            if (sameClassCandidates.length > 0) {
                html += '<div style="font-weight: bold; font-size: 11px; margin: 10px 0 5px 0; color: #4caf50;">‚úì Same Class</div>';
                sameClassCandidates.slice(0, 10).forEach(c => {
                    const disabled = c.alreadyAnnotated ? 'disabled' : '';
                    const btnText = c.alreadyAnnotated ? 'Annotated' : 'Mark Similar';
                    const previewClass = previewedCandidateId === c.id ? 'previewing' : '';
                    html += `<div class="candidate-item same-class ${previewClass}" onclick="togglePreviewCandidate(${c.id}, event)">
                        <div class="candidate-info">
                            <div class="candidate-label">${c.label}</div>
                            <div class="candidate-match">‚úì Matching class</div>
                        </div>
                        <div>
                            <button class="annotate-btn" onclick="createSimilarityAnnotation(${c.id}, event)" ${disabled}>${btnText}</button>
                        </div>
                    </div>`;
                });
            }
            
            if (otherCandidates.length > 0) {
                html += `<div style="font-weight: bold; font-size: 11px; margin: 10px 0 5px 0; color: #ff9800;">‚ö† Different Class (${otherCandidates.length})</div>`;
                otherCandidates.forEach(c => {
                    const disabled = c.alreadyAnnotated ? 'disabled' : '';
                    const btnText = c.alreadyAnnotated ? 'Annotated' : 'Mark Similar';
                    const previewClass = previewedCandidateId === c.id ? 'previewing' : '';
                    html += `<div class="candidate-item different-class ${previewClass}" onclick="togglePreviewCandidate(${c.id}, event)">
                        <div class="candidate-info">
                            <div class="candidate-label">${c.label}</div>
                            <div class="candidate-match">‚ö† Different class</div>
                        </div>
                        <div>
                            <button class="annotate-btn" onclick="createSimilarityAnnotation(${c.id}, event)" ${disabled}>${btnText}</button>
                        </div>
                    </div>`;
                });
            }
            
            container.innerHTML = html;
        }

        function updateAnnotationsDisplay() {
            const container = document.getElementById('annotations-container');
            let html = '';
            
            if (similarityAnnotations.length === 0) {
                html += '<div style="color: #999; font-size: 11px;">No annotations yet. Enable annotation mode and select objects.</div>';
            } else {
                similarityAnnotations.forEach((ann, idx) => {
                    const icon = ann.sameClass ? '‚úì' : '‚ö†';
                    const classInfo = ann.sameClass ? 'Same class' : 'Different classes';
                    html += `<div class="annotation-item">
                        <div>
                            <span style="color: ${ann.sameClass ? '#4caf50' : '#ff9800'};">${icon}</span>
                            <strong>${ann.label1}</strong> ‚Üî <strong>${ann.label2}</strong>
                            <div style="font-size: 9px; color: #999;">${classInfo}</div>
                        </div>
                        <button class="delete-btn" onclick="deleteAnnotation(${idx})">√ó</button>
                    </div>`;
                });
            }
            
            container.innerHTML = html;
        }

        function deleteAnnotation(index) {
            similarityAnnotations.splice(index, 1);
            updateAnnotationsDisplay();
            updateAnnotationLines();
        }

        // Attribute validation functions
        function validateAttribute(attrId, status, event) {
            if (event) event.stopPropagation();
            
            // Toggle validation: if already set to this status, clear it
            if (attributeValidations[attrId] === status) {
                delete attributeValidations[attrId];
            } else {
                attributeValidations[attrId] = status;
            }
            
            // Update the UI
            updateObjectsList();
            updateValidationStats();
        }
        
        function updateValidationStats() {
            const statsContainer = document.getElementById('validation-stats');
            if (!statsContainer) return;
            
            let html = '';
            
            // Show attribute stats only in attribute mode
            if (annotationMode === 'attribute') {
                const totalAttrs = sceneGraphData.attributes ? sceneGraphData.attributes.length : 0;
                const attrCorrectCount = Object.values(attributeValidations).filter(v => v === 'correct').length;
                const attrIncorrectCount = Object.values(attributeValidations).filter(v => v === 'incorrect').length;
                const attrAddedCount = additionalAttributes.length;
                
                html += `
                    <div>
                        <strong>Attrs:</strong> ${totalAttrs} | 
                        <span style="color: #28a745;">‚úì${attrCorrectCount}</span> 
                        <span style="color: #dc3545;">‚úó${attrIncorrectCount}</span> 
                        <span style="color: #28a745;">+${attrAddedCount}</span>
                    </div>
                `;
            }
            
            // Show relationship stats only in relationship mode
            if (annotationMode === 'relationship') {
                const totalRels = sceneGraphData.relationships ? sceneGraphData.relationships.length : 0;
                const relCorrectCount = Object.values(relationshipValidations).filter(v => v === 'correct').length;
                const relIncorrectCount = Object.values(relationshipValidations).filter(v => v === 'incorrect').length;
                const relAddedCount = additionalRelationships.length;
                
                html += `
                    <div>
                        <strong>Rels:</strong> ${totalRels} | 
                        <span style="color: #28a745;">‚úì${relCorrectCount}</span> 
                        <span style="color: #dc3545;">‚úó${relIncorrectCount}</span> 
                        <span style="color: #28a745;">+${relAddedCount}</span>
                    </div>
                `;
            }
            
            // Show similarity stats in similarity mode
            if (annotationMode === 'similarity') {
                html += `
                    <div>
                        <strong>Similar pairs:</strong> ${similarityAnnotations.length}
                    </div>
                `;
            }
            
            statsContainer.innerHTML = html;
        }
        
        function exportAnnotations() {
            if (!sceneGraphData && annotationMode !== 'similarity') {
                alert('No scene graph loaded');
                return;
            }
            
            const exportData = {
                scene_id: sceneGraphData?.id || currentSceneId,
                timestamp: new Date().toISOString(),
                annotation_type: annotationMode || 'all'
            };
            
            // Similarity (always include)
            exportData.similarity = {
                annotations: similarityAnnotations,
                summary: {
                    total: similarityAnnotations.length
                }
            };
            
            // Attributes (always include)
            const predictedAttrs = sceneGraphData?.attributes || [];
            exportData.attributes = {
                predicted: {
                    total: predictedAttrs.length,
                    items: predictedAttrs.map(attr => ({
                        id: attr.id,
                        object_id: attr.object_id,
                        name: attr.name,
                        type: attr.type || null,
                        validation: attributeValidations[attr.id] || null
                    }))
                },
                added: additionalAttributes,
                summary: {
                    predicted_total: predictedAttrs.length,
                    correct: Object.values(attributeValidations).filter(v => v === 'correct').length,
                    incorrect: Object.values(attributeValidations).filter(v => v === 'incorrect').length,
                    added: additionalAttributes.length
                }
            };
            
            // Relationships (always include)
            const predictedRels = sceneGraphData?.relationships || [];
            exportData.relationships = {
                predicted: {
                    total: predictedRels.length,
                    items: predictedRels.map((rel, idx) => ({
                        index: idx,
                        subject_id: rel.subject_id,
                        predicate: rel.name,
                        object_ids: rel.recipient_id || [],
                        validation: relationshipValidations[idx] || null
                    }))
                },
                added: additionalRelationships,
                summary: {
                    predicted_total: predictedRels.length,
                    correct: Object.values(relationshipValidations).filter(v => v === 'correct').length,
                    incorrect: Object.values(relationshipValidations).filter(v => v === 'incorrect').length,
                    added: additionalRelationships.length
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `annotations_${sceneGraphData?.id || currentSceneId}_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function clearAttributeValidations() {
            attributeValidations = {};
            additionalAttributes = [];
            relationshipValidations = {};
            additionalRelationships = [];
            updateObjectsList();
            updateRelationshipsDisplay(selectedObjectId);
            updateValidationStats();
        }
        
        // Additional/missing attribute annotation functions
        function toggleAddAttributeForm(objectId, event) {
            if (event) event.stopPropagation();
            const form = document.getElementById(`add-attr-form-${objectId}`);
            if (form) {
                form.classList.toggle('hidden');
            }
        }
        
        function addAnnotatedAttribute(objectId, event) {
            if (event) event.stopPropagation();
            
            const nameInput = document.getElementById(`attr-name-${objectId}`);
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('Please enter an attribute name');
                return;
            }
            
            const id = `added_${objectId}_${Date.now()}`;
            
            additionalAttributes.push({
                id: id,
                object_id: objectId,
                name: name,
                timestamp: new Date().toISOString()
            });
            
            // Clear input
            nameInput.value = '';
            
            // Update UI
            updateObjectsList();
            updateValidationStats();
        }
        
        function deleteAnnotatedAttribute(attrId, event) {
            if (event) event.stopPropagation();
            
            const index = additionalAttributes.findIndex(a => a.id === attrId);
            if (index !== -1) {
                additionalAttributes.splice(index, 1);
                updateObjectsList();
                updateValidationStats();
            }
        }
        
        // Relationship validation functions
        function validateRelationship(relIndex, status, event) {
            if (event) event.stopPropagation();
            
            // Toggle validation: if already set to this status, clear it
            if (relationshipValidations[relIndex] === status) {
                delete relationshipValidations[relIndex];
            } else {
                relationshipValidations[relIndex] = status;
            }
            
            // Update the UI
            updateRelationshipsDisplay(selectedObjectId);
            updateValidationStats();
        }
        
        function addRelationship(subjectId, event) {
            if (event) event.stopPropagation();
            
            const predicateInput = document.getElementById(`rel-predicate-${subjectId}`);
            const objectSelect = document.getElementById(`rel-object-${subjectId}`);
            
            const predicate = predicateInput.value.trim();
            const objectId = parseInt(objectSelect.value);
            
            if (!predicate) {
                alert('Please select a predicate');
                return;
            }
            if (!objectId) {
                alert('Please select a target object');
                return;
            }
            
            const id = `added_rel_${subjectId}_${objectId}_${Date.now()}`;
            
            additionalRelationships.push({
                id: id,
                subject_id: subjectId,
                object_id: objectId,
                predicate: predicate,
                timestamp: new Date().toISOString()
            });
            
            // Clear inputs
            predicateInput.value = '';
            objectSelect.value = '';
            
            // Update UI
            updateRelationshipsDisplay(selectedObjectId);
            updateValidationStats();
        }
        
        function deleteAddedRelationship(relId, event) {
            if (event) event.stopPropagation();
            
            const index = additionalRelationships.findIndex(r => r.id === relId);
            if (index !== -1) {
                additionalRelationships.splice(index, 1);
                updateRelationshipsDisplay(selectedObjectId);
                updateValidationStats();
            }
        }

        function updateAnnotationLines() {
            // Remove existing annotation lines
            annotationLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            annotationLines = [];
            
            if (annotationMode !== 'similarity') return;
            
            // Draw lines for all similarity annotations
            similarityAnnotations.forEach(ann => {
                const bbox1 = bboxes.find(b => b.userData.objectId === ann.id1);
                const bbox2 = bboxes.find(b => b.userData.objectId === ann.id2);
                
                if (bbox1 && bbox2) {
                    const points = [];
                    points.push(bbox1.position.clone());
                    points.push(bbox2.position.clone());
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const color = ann.sameClass ? 0x9c27b0 : 0xff9800; // Purple for same class, orange for different
                    const material = new THREE.LineDashedMaterial({ 
                        color: color,
                        linewidth: 2,
                        dashSize: 0.3,
                        gapSize: 0.1,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.computeLineDistances(); // Required for dashed lines
                    annotationLines.push(line);
                    scene.add(line);
                    
                    // Show both bboxes
                    scene.add(bbox1);
                    scene.add(bbox2);
                }
            });
        }

        function highlightRelatedObject(objectId) {
            // Toggle highlight
            if (highlightedObjectIds.has(objectId)) {
                highlightedObjectIds.delete(objectId);
            } else {
                // Assign a color to this object
                const color = highlightColors[nextColorIndex % highlightColors.length];
                highlightedObjectIds.set(objectId, color);
                nextColorIndex++;
            }
            updateBoundingBoxes();
            updateRelationshipsDisplay(selectedObjectId); // Refresh to update visual indicators
            updateRelationshipLines(); // Draw/update lines to highlighted objects
        }
        
        function highlightBothObjects(objectId1, objectId2) {
            // Check if both are already highlighted
            const bothHighlighted = highlightedObjectIds.has(objectId1) && highlightedObjectIds.has(objectId2);
            
            if (bothHighlighted) {
                // Remove both
                highlightedObjectIds.delete(objectId1);
                highlightedObjectIds.delete(objectId2);
            } else {
                // Add both (if not already highlighted)
                if (!highlightedObjectIds.has(objectId1)) {
                    const color1 = highlightColors[nextColorIndex % highlightColors.length];
                    highlightedObjectIds.set(objectId1, color1);
                    nextColorIndex++;
                }
                if (!highlightedObjectIds.has(objectId2)) {
                    const color2 = highlightColors[nextColorIndex % highlightColors.length];
                    highlightedObjectIds.set(objectId2, color2);
                    nextColorIndex++;
                }
            }
            updateBoundingBoxes();
            updateRelationshipsDisplay(selectedObjectId);
            updateRelationshipLines();
        }

        function updateBoundingBoxes() {
            bboxes.forEach(bbox => {
                const objId = bbox.userData.objectId;
                if (objId === selectedObjectId && annotationMode === 'similarity') {
                    // Selected object in similarity mode - show in purple
                    bbox.material.color.setHex(0x9c27b0);
                    bbox.material.opacity = 1.0;
                    scene.add(bbox);
                } else if (objId === selectedObjectId) {
                    // Selected object in normal/attribute/relationship mode - show in green
                    bbox.material.color.setHex(0x00ff00);
                    bbox.material.opacity = 1.0;
                    scene.add(bbox);
                } else if (objId === previewedCandidateId && annotationMode === 'similarity') {
                    // Previewed candidate in similarity mode - show in blue
                    bbox.material.color.setHex(0x42a5f5);
                    bbox.material.opacity = 1.0;
                    scene.add(bbox);
                } else if (highlightedObjectIds.has(objId)) {
                    // Highlighted related object - show in assigned color
                    const color = highlightedObjectIds.get(objId);
                    bbox.material.color.setHex(color.hex);
                    bbox.material.opacity = 1.0;
                    scene.add(bbox);
                } else {
                    // Other objects - show in red only if "Show All" is checked
                    bbox.material.color.setHex(0xff0000);
                    bbox.material.opacity = 0.7;
                    if (showAllBboxes) {
                        scene.add(bbox);
                    } else {
                        scene.remove(bbox);
                    }
                }
            });
        }

        function updateRelationshipsDisplay(objectId) {
            const container = document.getElementById('relationships-container');
            if (!sceneGraphData || objectId === null) {
                container.innerHTML = 'Select an object to view its relationships';
                return;
            }
            
            const relationships = sceneGraphData.relationships || [];

            // Find relationships where this object is the subject or recipient
            let outgoing = relationships.filter(rel => rel.subject_id === objectId);
            let incoming = relationships.filter(rel => 
                rel.recipient_id && rel.recipient_id.includes(objectId)
            );
            
            // Separate "in between" relationships - only when selected object is the middle node
            let inBetween = [];
            
            // From outgoing: subject is the selected object (selected is the middle)
            const outgoingBetween = outgoing.filter(rel => 
                rel.name.toLowerCase().includes('between') && rel.recipient_id && rel.recipient_id.length >= 2
            );
            inBetween.push(...outgoingBetween);
            
            // Remove "in between" from outgoing
            outgoing = outgoing.filter(rel => !outgoingBetween.includes(rel));
            
            // Remove "in between" from incoming as well
            incoming = incoming.filter(rel => 
                !(rel.name.toLowerCase().includes('between') && rel.recipient_id && rel.recipient_id.length >= 2)
            );
            
            // Get added relationships for this object
            const addedRels = additionalRelationships.filter(rel => 
                rel.subject_id === objectId || rel.object_id === objectId
            );
            
            // Apply relationship type filters
            if (selectedRelTypeFilters.size > 0) {
                outgoing = outgoing.filter(rel => selectedRelTypeFilters.has(rel.name));
                incoming = incoming.filter(rel => selectedRelTypeFilters.has(rel.name));
                inBetween = inBetween.filter(rel => selectedRelTypeFilters.has(rel.name));
            }

            const hasRelationships = outgoing.length > 0 || incoming.length > 0 || inBetween.length > 0 || addedRels.length > 0;
            
            if (!hasRelationships) {
                const msg = selectedRelTypeFilters.size > 0 
                    ? '<div style="color: #999; font-size: 12px;">No relationships match the selected filters</div>'
                    : '<div style="color: #999; font-size: 12px;">No relationships found</div>';
                container.innerHTML = msg + buildAddRelationshipForm(objectId);
                return;
            }

            let html = '';
            
            // Show filter status if filters are active
            if (selectedRelTypeFilters.size > 0) {
                const totalAll = relationships.filter(rel => 
                    rel.subject_id === objectId || (rel.recipient_id && rel.recipient_id.includes(objectId))
                ).length;
                const totalDisplayed = outgoing.length + incoming.length + inBetween.length;
                
                html += `<div style="padding: 8px; font-size: 11px; color: #666; background: #f0f0f0; border-radius: 3px; margin-bottom: 8px;">
                    Showing ${totalDisplayed} of ${totalAll} relationships
                </div>`;
            }
            
            // Helper to create validation buttons - only in relationship mode
            function getRelValidationButtons(relIndex) {
                if (annotationMode !== 'relationship') return '';
                const validation = relationshipValidations[relIndex];
                return `<span class="rel-validation-btns">
                    <button class="rel-validation-btn correct ${validation === 'correct' ? 'active' : ''}" 
                            onclick="validateRelationship(${relIndex}, 'correct', event)" title="Mark correct">‚úì</button>
                    <button class="rel-validation-btn incorrect ${validation === 'incorrect' ? 'active' : ''}" 
                            onclick="validateRelationship(${relIndex}, 'incorrect', event)" title="Mark incorrect">‚úó</button>
                </span>`;
            }
            
            function getRelValidationClass(relIndex) {
                const validation = relationshipValidations[relIndex];
                if (validation === 'correct') return 'validated-correct';
                if (validation === 'incorrect') return 'validated-incorrect';
                return '';
            }
            
            if (outgoing.length > 0) {
                html += '<div style="font-weight: bold; margin-bottom: 5px; font-size: 12px;">Outgoing:</div>';
                outgoing.forEach(rel => {
                    const relIndex = relationships.indexOf(rel);
                    const targetIds = rel.recipient_id || [];
                    targetIds.forEach(targetId => {
                        const targetObj = sceneGraphData.objects.find(o => o.id === targetId);
                        const targetLabel = targetObj ? (targetObj.labels[0] || `Object ${targetId}`) : `Object ${targetId}`;
                        let style = '';
                        if (highlightedObjectIds.has(targetId)) {
                            const color = highlightedObjectIds.get(targetId);
                            style = `style="background: ${color.css}; color: white; font-weight: bold; border: 2px solid ${color.border}; padding: 2px 6px; border-radius: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"`;
                        }
                        html += `<div class="relationship-item ${getRelValidationClass(relIndex)}">
                            <span style="color: #666;">‚Üí</span>
                            <span class="rel-name"> ${rel.name} </span>
                            <span style="color: #666;">‚Üí</span>
                            <span class="rel-target" ${style} onclick="highlightRelatedObject(${targetId})">${targetLabel}</span>
                            ${getRelValidationButtons(relIndex)}
                        </div>`;
                    });
                });
            }

            if (incoming.length > 0) {
                html += '<div style="font-weight: bold; margin: 10px 0 5px 0; font-size: 12px;">Incoming:</div>';
                incoming.forEach(rel => {
                    const relIndex = relationships.indexOf(rel);
                    const sourceObj = sceneGraphData.objects.find(o => o.id === rel.subject_id);
                    const sourceLabel = sourceObj ? (sourceObj.labels[0] || `Object ${rel.subject_id}`) : `Object ${rel.subject_id}`;
                    let style = '';
                    if (highlightedObjectIds.has(rel.subject_id)) {
                        const color = highlightedObjectIds.get(rel.subject_id);
                        style = `style="background: ${color.css}; color: white; font-weight: bold; border: 2px solid ${color.border}; padding: 2px 6px; border-radius: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"`;
                    }
                    html += `<div class="relationship-item ${getRelValidationClass(relIndex)}">
                        <span style="color: #666;">‚Üê</span>
                        <span class="rel-name"> ${rel.name} </span>
                        <span style="color: #666;">‚Üê</span>
                        <span class="rel-target" ${style} onclick="highlightRelatedObject(${rel.subject_id})">${sourceLabel}</span>
                        ${getRelValidationButtons(relIndex)}
                    </div>`;
                });
            }
            
            if (inBetween.length > 0) {
                html += '<div style="font-weight: bold; margin: 10px 0 5px 0; font-size: 12px; background: #e8f4fc; padding: 5px; border-radius: 3px;">In Between:</div>';
                inBetween.forEach(rel => {
                    const relIndex = relationships.indexOf(rel);
                    const targetIds = rel.recipient_id || [];
                    
                    // Selected object is the middle - show both endpoints
                    const target1Obj = sceneGraphData.objects.find(o => o.id === targetIds[0]);
                    const target2Obj = sceneGraphData.objects.find(o => o.id === targetIds[1]);
                    
                    const target1Label = target1Obj ? (target1Obj.labels[0] || `Object ${targetIds[0]}`) : `Object ${targetIds[0]}`;
                    const target2Label = target2Obj ? (target2Obj.labels[0] || `Object ${targetIds[1]}`) : `Object ${targetIds[1]}`;
                    
                    let style1 = '';
                    let style2 = '';
                    
                    if (highlightedObjectIds.has(targetIds[0])) {
                        const color = highlightedObjectIds.get(targetIds[0]);
                        style1 = `style="background: ${color.css}; color: white; font-weight: bold; border: 2px solid ${color.border}; padding: 2px 6px; border-radius: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"`;
                    }
                    if (highlightedObjectIds.has(targetIds[1])) {
                        const color = highlightedObjectIds.get(targetIds[1]);
                        style2 = `style="background: ${color.css}; color: white; font-weight: bold; border: 2px solid ${color.border}; padding: 2px 6px; border-radius: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"`;
                    }
                    
                    const bothHighlighted = highlightedObjectIds.has(targetIds[0]) && highlightedObjectIds.has(targetIds[1]);
                    
                    // Display: [endpoint1] ‚Üê (selected is between) ‚Üí [endpoint2]
                    html += `<div class="relationship-item in-between-item ${getRelValidationClass(relIndex)}">
                        <span class="rel-target" ${style1} onclick="highlightRelatedObject(${targetIds[0]})">${target1Label}</span>
                        <span style="color: #666;">‚Üê</span>
                        <span class="rel-name">(${rel.name})</span>
                        <span style="color: #666;">‚Üí</span>
                        <span class="rel-target" ${style2} onclick="highlightRelatedObject(${targetIds[1]})">${target2Label}</span>
                        <button class="highlight-both-btn ${bothHighlighted ? 'active' : ''}" 
                                onclick="highlightBothObjects(${targetIds[0]}, ${targetIds[1]})" 
                                title="Highlight both objects">‚ö°</button>
                        ${getRelValidationButtons(relIndex)}
                    </div>`;
                });
            }
            
            // Show added relationships
            if (addedRels.length > 0) {
                html += '<div style="font-weight: bold; margin: 10px 0 5px 0; font-size: 12px;">Added:</div>';
                addedRels.forEach(rel => {
                    const otherObjId = rel.subject_id === objectId ? rel.object_id : rel.subject_id;
                    const otherObj = sceneGraphData.objects.find(o => o.id === otherObjId);
                    const otherLabel = otherObj ? (otherObj.labels[0] || `Object ${otherObjId}`) : `Object ${otherObjId}`;
                    const direction = rel.subject_id === objectId ? '‚Üí' : '‚Üê';
                    
                    // Only show delete button in relationship mode
                    const deleteBtnHTML = annotationMode === 'relationship' ? 
                        `<button class="rel-delete-btn" onclick="deleteAddedRelationship('${rel.id}', event)" title="Remove">√ó</button>` : '';
                    
                    html += `<div class="relationship-item added-relationship">
                        <span class="rel-name">${rel.predicate}</span> ${direction} 
                        <span class="rel-target" onclick="highlightRelatedObject(${otherObjId})">${otherLabel}</span>
                        ${deleteBtnHTML}
                    </div>`;
                });
            }
            
            // Add relationship form
            html += buildAddRelationshipForm(objectId);

            container.innerHTML = html;
        }
        
        function buildAddRelationshipForm(objectId) {
            // Only show form in relationship mode
            if (annotationMode !== 'relationship') return '';
            if (!sceneGraphData || !sceneGraphData.objects) return '';
            
            // Build object options
            const objectOptions = sceneGraphData.objects
                .filter(o => o.id !== objectId)
                .map(o => `<option value="${o.id}">${o.labels[0] || 'Object ' + o.id} (${o.id})</option>`)
                .join('');
            
            // Use global predicates list (collected from all scene graphs)
            const predicateOptions = (allPredicates || [])
                .map(p => `<option value="${p}">${p}</option>`)
                .join('');
            
            return `
                <div id="add-relationship-section">
                    <h4>Add Relationship</h4>
                    <div class="add-rel-row">
                        <span style="font-size: 11px;">Subject: Current Object</span>
                    </div>
                    <div class="add-rel-row">
                        <select class="add-rel-select" id="rel-predicate-${objectId}" style="flex: 1;">
                            <option value="">Select predicate...</option>
                            ${predicateOptions}
                        </select>
                        <select class="add-rel-select" id="rel-object-${objectId}">
                            <option value="">Select object...</option>
                            ${objectOptions}
                        </select>
                    </div>
                    <div class="add-rel-row">
                        <button class="add-rel-btn" onclick="addRelationship(${objectId}, event)">Add Relationship</button>
                    </div>
                </div>
            `;
        }

        function updateRelationshipLines() {
            // Remove existing relationship lines
            relationshipLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            relationshipLines = [];
            
            // Don't show lines in similarity mode or if no object selected
            if (annotationMode === 'similarity' || selectedObjectId === null) {
                return;
            }
            
            const selectedBbox = bboxes.find(b => b.userData.objectId === selectedObjectId);
            if (!selectedBbox) return;
            
            // Draw lines only for highlighted related objects
            highlightedObjectIds.forEach((color, relatedObjectId) => {
                const relatedBbox = bboxes.find(b => b.userData.objectId === relatedObjectId);
                if (relatedBbox) {
                    const points = [];
                    points.push(selectedBbox.position.clone());
                    points.push(relatedBbox.position.clone());
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: color.hex,
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    relationshipLines.push(line);
                    scene.add(line);
                }
            });
        }

        // Filter functions
        function initializeFilters() {
            if (!sceneGraphData) return;
            
            // Initialize attribute filters
            const attributeSet = new Set();
            if (sceneGraphData.attributes && sceneGraphData.attributes.length > 0) {
                sceneGraphData.attributes.forEach(attr => {
                    if (attr.name) attributeSet.add(attr.name);
                });
            }
            
            const attributeFilter = document.getElementById('attribute-filter');
            attributeFilter.innerHTML = '<option value="">All attributes</option>';
            Array.from(attributeSet).sort().forEach(attr => {
                const option = document.createElement('option');
                option.value = attr;
                option.textContent = attr;
                attributeFilter.appendChild(option);
            });
            
            // Initialize relationship type filters
            const relTypeSet = new Set();
            if (sceneGraphData.relationships && sceneGraphData.relationships.length > 0) {
                sceneGraphData.relationships.forEach(rel => {
                    if (rel.name) relTypeSet.add(rel.name);
                });
            }
            
            const relTypeFilter = document.getElementById('relationship-type-filter');
            relTypeFilter.innerHTML = '<option value="">All types</option>';
            Array.from(relTypeSet).sort().forEach(relType => {
                const option = document.createElement('option');
                option.value = relType;
                option.textContent = relType;
                relTypeFilter.appendChild(option);
            });
        }
        
        function addAttributeFilter(attribute) {
            if (!attribute || selectedAttributeFilters.has(attribute)) return;
            selectedAttributeFilters.add(attribute);
            updateAttributeFilterChips();
            updateObjectsList();
            document.getElementById('clear-object-filters').style.display = 'block';
        }
        
        function removeAttributeFilter(attribute) {
            selectedAttributeFilters.delete(attribute);
            updateAttributeFilterChips();
            updateObjectsList();
            if (selectedAttributeFilters.size === 0) {
                document.getElementById('clear-object-filters').style.display = 'none';
            }
        }
        
        function updateAttributeFilterChips() {
            const container = document.getElementById('selected-attributes');
            container.innerHTML = '';
            selectedAttributeFilters.forEach(attr => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.innerHTML = `${attr} <span class="remove">√ó</span>`;
                chip.onclick = () => removeAttributeFilter(attr);
                container.appendChild(chip);
            });
        }
        
        function addRelTypeFilter(relType) {
            if (!relType || selectedRelTypeFilters.has(relType)) return;
            selectedRelTypeFilters.add(relType);
            updateRelTypeFilterChips();
            if (selectedObjectId !== null) {
                updateRelationshipsDisplay(selectedObjectId);
            }
            document.getElementById('clear-rel-filters').style.display = 'block';
        }
        
        function removeRelTypeFilter(relType) {
            selectedRelTypeFilters.delete(relType);
            updateRelTypeFilterChips();
            if (selectedObjectId !== null) {
                updateRelationshipsDisplay(selectedObjectId);
            }
            if (selectedRelTypeFilters.size === 0) {
                document.getElementById('clear-rel-filters').style.display = 'none';
            }
        }
        
        function updateRelTypeFilterChips() {
            const container = document.getElementById('selected-rel-types');
            container.innerHTML = '';
            selectedRelTypeFilters.forEach(relType => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.innerHTML = `${relType} <span class="remove">√ó</span>`;
                chip.onclick = () => removeRelTypeFilter(relType);
                container.appendChild(chip);
            });
        }
        
        function clearAllObjectFilters() {
            selectedAttributeFilters.clear();
            updateAttributeFilterChips();
            updateObjectsList();
            document.getElementById('clear-object-filters').style.display = 'none';
        }
        
        function clearAllRelFilters() {
            selectedRelTypeFilters.clear();
            updateRelTypeFilterChips();
            if (selectedObjectId !== null) {
                updateRelationshipsDisplay(selectedObjectId);
            }
            document.getElementById('clear-rel-filters').style.display = 'none';
        }
        
        function objectMatchesFilters(obj) {
            // If no filters selected, show all objects
            if (selectedAttributeFilters.size === 0) return true;
            
            // Get attributes for this object
            const objAttributes = sceneGraphData.attributes
                ? sceneGraphData.attributes.filter(attr => attr.object_id === obj.id).map(attr => attr.name)
                : [];
            
            // Object must have at least one of the selected attributes
            for (let attr of selectedAttributeFilters) {
                if (objAttributes.includes(attr)) return true;
            }
            return false;
        }

        // Event listeners for controls
        document.getElementById('show-all-bboxes').addEventListener('change', (e) => {
            showAllBboxes = e.target.checked;
            updateBoundingBoxes();
        });
        
        // Filter event listeners
        document.getElementById('attribute-filter').addEventListener('change', (e) => {
            const value = e.target.value;
            if (value) {
                addAttributeFilter(value);
                e.target.value = ''; // Reset dropdown
            }
        });
        
        document.getElementById('relationship-type-filter').addEventListener('change', (e) => {
            const value = e.target.value;
            if (value) {
                addRelTypeFilter(value);
                e.target.value = ''; // Reset dropdown
            }
        });
        
        document.getElementById('clear-object-filters').addEventListener('click', clearAllObjectFilters);
        document.getElementById('clear-rel-filters').addEventListener('click', clearAllRelFilters);

        function setAnnotationMode(mode) {
            annotationMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active', 'similarity', 'attribute', 'relationship');
            });
            
            const activeBtn = document.getElementById(`mode-${mode || 'none'}`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                if (mode) activeBtn.classList.add(mode);
            }
            
            // Update info text based on mode
            const infoEl = document.getElementById('annotation-info');
            if (mode === 'similarity') {
                infoEl.textContent = 'Select two objects to mark as similar';
                infoEl.style.display = 'block';
            } else if (mode === 'attribute') {
                infoEl.textContent = 'Validate attributes (‚úì/‚úó) or add new ones';
                infoEl.style.display = 'block';
            } else if (mode === 'relationship') {
                infoEl.textContent = 'Validate relationships (‚úì/‚úó) or add new ones';
                infoEl.style.display = 'block';
            } else {
                infoEl.style.display = 'none';
            }
            
            // Show/hide relationship filters (hidden in similarity mode)
            const relFilters = document.getElementById('relationship-filters');
            if (relFilters) {
                relFilters.style.display = mode === 'similarity' ? 'none' : 'block';
            }
            
            // Update panel title
            const title = document.getElementById('relationships-title');
            if (title) {
                if (mode === 'similarity') {
                    title.textContent = 'Similar Object Candidates';
                } else if (mode === 'relationship') {
                    title.textContent = 'Relationships (Annotation)';
                } else {
                    title.textContent = 'Relationships';
                }
            }
            
            // Refresh the objects list to show/hide attribute annotation UI
            updateObjectsList();
            
            if (mode === 'similarity') {
                // Keep selection if any
                highlightedObjectIds.clear();
                showAnnotationCandidates(selectedObjectId);
                // Clear relationship lines in similarity mode
                updateRelationshipLines();
            } else {
                // Back to normal/attribute/relationship mode
                updateRelationshipsDisplay(selectedObjectId);
                // Restore relationship lines (only if objects are highlighted)
                updateRelationshipLines();
            }
            
            updateBoundingBoxes();
            updateAnnotationsDisplay();
            updateAnnotationLines();
            updateValidationStats();
        }
        
        // Initialize with mode off
        setAnnotationMode(null);

        document.getElementById('export-annotations').addEventListener('click', () => {
            exportAnnotations();
        });

        document.getElementById('show-points').addEventListener('change', (e) => {
            if (pointCloud) {
                pointCloud.visible = e.target.checked;
            }
        });

        // Point size control
        const pointSizeSlider = document.getElementById('point-size');
        const pointSizeValue = document.getElementById('point-size-value');
        if (pointSizeSlider && pointSizeValue) {
            pointSizeSlider.addEventListener('input', (e) => {
                const size = parseFloat(e.target.value);
                pointSizeValue.textContent = size.toFixed(1);
                if (pointCloud && pointCloud.material) {
                    pointCloud.material.size = size;
                }
            });
        }

        // Scene loading functions
        function populateScenesList() {
            const container = document.getElementById('scenes-list');
            container.innerHTML = '';
            
            availableScenes.forEach(sceneId => {
                const div = document.createElement('div');
                div.className = 'scene-item';
                // Highlight if this is the currently loaded scene
                if (sceneId === currentSceneId) {
                    div.classList.add('selected');
                }
                div.textContent = sceneId;
                div.addEventListener('click', () => loadScene(sceneId));
                container.appendChild(div);
            });
        }

        async function loadScene(sceneId) {
            if (currentSceneId === sceneId) return;
            
            // Auto-detect dataset from scene ID pattern
            currentDataset = getDatasetFromSceneId(sceneId);
            currentSceneId = sceneId;
            document.getElementById('loading').classList.remove('hidden');
            
            // Update selected scene in list
            document.querySelectorAll('.scene-item').forEach(item => {
                item.classList.toggle('selected', item.textContent === sceneId);
            });
            
            try {
                // Load scene graph based on dataset type
                let sgUrl, plyUrls, alignUrl = null, colorUrl = null;
                
                if (currentDataset === 'multiscan') {
                    // Load scene graph from scenegraphs directory (has proper relationships & attributes)
                    sgUrl = `data/scenegraphs/multiscan/${sceneId}/scene_graph.json`;
                    alignUrl = `data/multiscan/${sceneId}/${sceneId}.align.json`;
                    // PLY mesh is still in the multiscan data directory
                    plyUrls = [
                        `data/multiscan/${sceneId}/${sceneId}.ply`
                    ];
                } else if (currentDataset === '3rscan') {
                    // 3RScan scenes
                    sgUrl = `data/scenegraphs/3rscan/${sceneId}/scene_graph.json`;
                    // 3RScan: use labeled mesh for geometry (has faces)
                    plyUrls = [
                        `data/3rscan/download/${sceneId}/labels.instances.align.annotated.v2.ply`,
                        `data/3rscan/download/${sceneId}/labels.instances.annotated.v2.ply`,
                        `data/3rscan/download/${sceneId}/labels.instances.annotated.ply`
                    ];
                    // Also try to load real colors from color.align.ply
                    colorUrl = `data/3rscan/download/${sceneId}/color.align.ply`;
                } else {
                    sgUrl = `data/scenegraphs/scannet/${sceneId}/scene_graph.json`;
                    plyUrls = [
                        `data/scannet/public/v2/scans/${sceneId}/${sceneId}_vh_clean.ply`,
                        `data/scannet/public/v2/scans/${sceneId}/${sceneId}_vh_clean_2.ply`,
                        `data/scannet/public/v2/scans/${sceneId}/${sceneId}_vh_clean_2.labels.ply`
                    ];
                }
                
                // Load alignment transform for multiscan
                let alignTransform = null;
                if (alignUrl) {
                    try {
                        const alignResponse = await fetch(alignUrl);
                        if (alignResponse.ok) {
                            const alignData = await alignResponse.json();
                            alignTransform = alignData.coordinate_transform;
                            console.log('Loaded alignment transform:', alignTransform);
                        }
                    } catch (e) {
                        console.warn('Could not load alignment transform:', e);
                    }
                }
                
                const sgResponse = await fetch(sgUrl);
                const sgText = await sgResponse.text();
                let data = JSON.parse(sgText);
                
                // The scene_graph.json files are already in the correct format for both datasets
                sceneGraphData = data;
                console.log('Loaded scene graph:', sceneGraphData.id, 'with', 
                    (sceneGraphData.objects || []).length, 'objects,',
                    (sceneGraphData.relationships || []).length, 'relationships,',
                    (sceneGraphData.attributes || []).length, 'attributes');
                
                // Clear filters when loading new scene
                selectedAttributeFilters.clear();
                selectedRelTypeFilters.clear();
                updateAttributeFilterChips();
                updateRelTypeFilterChips();
                document.getElementById('clear-object-filters').style.display = 'none';
                document.getElementById('clear-rel-filters').style.display = 'none';
                
                initializeFilters();
                updateSceneInfo();
                loadBoundingBoxes();
                updateObjectsList();
                
                // Clear all validations and annotations for new scene
                attributeValidations = {};
                additionalAttributes = [];
                relationshipValidations = {};
                additionalRelationships = [];
                updateValidationStats();
                
                // Try textured mesh first for multiscan / 3rscan, then fall back to PLY
                let meshLoaded = false;
                const meshCandidates = [];
                if (currentDataset === 'multiscan') {
                    meshCandidates.push({
                        obj: `data/multiscan/${sceneId}/textured_mesh/${sceneId}.obj`,
                        mtl: `data/multiscan/${sceneId}/textured_mesh/${sceneId}.mtl`
                    });
                } else if (currentDataset === '3rscan') {
                    meshCandidates.push({
                        obj: `data/3rscan/download/${sceneId}/mesh.refined.obj`,
                        mtl: `data/3rscan/download/${sceneId}/mesh.refined.mtl`
                    });
                    meshCandidates.push({
                        obj: `data/3rscan/download/${sceneId}/textured_mesh/${sceneId}.obj`,
                        mtl: `data/3rscan/download/${sceneId}/textured_mesh/${sceneId}.mtl`
                    });
                }

                for (const mesh of meshCandidates) {
                    try {
                        await loadTexturedMesh(mesh);
                        meshLoaded = true;
                        console.log('Loaded textured mesh:', mesh.obj);
                        break;
                    } catch (meshErr) {
                        console.warn('Failed to load textured mesh', mesh.obj, '-', meshErr.message || meshErr);
                    }
                }

                // Load point cloud - try various naming patterns if mesh was not loaded
                let plyLoaded = meshLoaded;
                
                if (!meshLoaded) {
                    for (const plyUrl of plyUrls) {
                        try {
                            console.log('Attempting to fetch:', plyUrl);
                            const plyResponse = await fetch(plyUrl);
                            console.log('Fetch response status:', plyResponse.status, plyResponse.statusText);
                            if (!plyResponse.ok) {
                                throw new Error(`HTTP ${plyResponse.status}: ${plyResponse.statusText}`);
                            }
                            console.log('Loading PLY from:', plyUrl);
                            const plyArrayBuffer = await plyResponse.arrayBuffer();
                            console.log('PLY file loaded, size:', plyArrayBuffer.byteLength, 'bytes');
                            const pcData = await parsePLY(plyArrayBuffer);
                            console.log('Parsed PLY - points:', pcData.points.length / 3, 'hasColors:', pcData.hasColors);
                            
                            if (!pcData.points || pcData.points.length === 0) {
                                throw new Error('No points found in PLY file');
                            }
                            
                            // For multiscan/3rscan: Check if we need coordinate transforms
                            // The annotations use Z-up coordinate system (based on "up": [0, 0, 1] in bbox)
                            // Log info to help debug coordinate alignment
                            if (currentDataset === 'multiscan' || currentDataset === '3rscan') {
                                console.log(currentDataset + ' PLY loaded without transform - checking alignment');
                                console.log('Raw mesh first vertex:', pcData.points[0].toFixed(4), pcData.points[1].toFixed(4), pcData.points[2].toFixed(4));
                            }
                            
                            // For 3RScan: try to load real colors from separate file
                            if (colorUrl && currentDataset === '3rscan') {
                                try {
                                    console.log('Attempting to load real colors from:', colorUrl);
                                    const colorResponse = await fetch(colorUrl);
                                    if (colorResponse.ok) {
                                        const colorArrayBuffer = await colorResponse.arrayBuffer();
                                        const colorData = await parsePLY(colorArrayBuffer);
                                        // Only use if vertex count matches
                                        if (colorData.points.length === pcData.points.length && colorData.hasColors) {
                                            console.log('Applying real colors from color.align.ply');
                                            pcData.colors = colorData.colors;
                                            pcData.hasColors = true;
                                        } else {
                                            console.warn('Color file vertex count mismatch:', colorData.points.length / 3, 'vs', pcData.points.length / 3);
                                        }
                                    }
                                } catch (colorErr) {
                                    console.warn('Could not load real colors:', colorErr.message);
                                }
                            }
                            
                            // Sample if too many points (only if no faces, as sampling would break face indices)
                            if (!pcData.hasFaces) {
                                const maxPoints = 200000;
                                const numVertices = pcData.points.length / 3;
                                if (numVertices > maxPoints) {
                                    console.log('Sampling point cloud from', numVertices, 'to', maxPoints, 'points');
                                    const step = Math.floor(numVertices / maxPoints);
                                    const sampledPoints = [];
                                    const sampledColors = [];
                                    for (let v = 0; v < numVertices; v += step) {
                                        const idx = v * 3;
                                        sampledPoints.push(pcData.points[idx], pcData.points[idx+1], pcData.points[idx+2]);
                                        if (pcData.hasColors && pcData.colors) {
                                            const colorIdx = v * 3;
                                            sampledColors.push(pcData.colors[colorIdx], pcData.colors[colorIdx+1], pcData.colors[colorIdx+2]);
                                        }
                                    }
                                    pcData.points = sampledPoints;
                                    pcData.colors = sampledColors;
                                    console.log('Sampled to', sampledPoints.length / 3, 'points');
                                }
                            }
                            
                        loadPointCloud(pcData);
                        plyLoaded = true;
                        console.log('Point cloud loaded successfully from:', plyUrl);
                        break; // Success, exit the loop
                        } catch (plyError) {
                            console.warn('Failed to load from', plyUrl, '- Error:', plyError.message || plyError);
                            // Try next URL
                            continue;
                        }
                    }
                }
                
                if (!plyLoaded) {
                    console.error('Could not load mesh or PLY file from any location');
                    alert('Warning: Could not load geometry. Bounding boxes will be shown, but no mesh/point cloud data.');
                }
            } catch (error) {
                console.error('Error loading scene:', error);
                alert('Error loading scene: ' + error.message);
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        // Initialize
        initViewer();
        populateScenesList();
    </script>
</body>
</html>
